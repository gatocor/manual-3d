"""
This module contains four napari widgets declared in
different ways:

- a pure Python function flagged with `autogenerate: true`
    in the plugin manifest. Type annotations are used by
    magicgui to generate widgets for each parameter. Best
    suited for simple processing tasks - usually taking
    in and/or returning a layer.
- a `magic_factory` decorated function. The `magic_factory`
    decorator allows us to customize aspects of the resulting
    GUI, including the widgets associated with each parameter.
    Best used when you have a very simple processing task,
    but want some control over the autogenerated widgets. If you
    find yourself needing to define lots of nested functions to achieve
    your functionality, maybe look at the `Container` widget!
- a `magicgui.widgets.Container` subclass. This provides lots
    of flexibility and customization options while still supporting
    `magicgui` widgets and convenience methods for creating widgets
    from type annotations. If you want to customize your widgets and
    connect callbacks, this is the best widget option for you.
- a `QWidget` subclass. This provides maximal flexibility but requires
    full specification of widget layouts, callbacks, events, etc.

References:
- Widget specification: https://napari.org/stable/plugins/guides.html?#widgets
- magicgui docs: https://pyapp-kit.github.io/magicgui/

Replace code below according to your needs.
"""
from typing import TYPE_CHECKING

from magicgui import magic_factory
from magicgui.widgets import CheckBox, Container, create_widget
from qtpy.QtWidgets import (
    QWidget, QVBoxLayout, QLabel, QCheckBox, QPushButton, QLineEdit, QFileDialog, QDoubleSpinBox, QSpinBox, QMessageBox, QApplication, QWidget, QDialog
)
from qtpy.QtCore import Qt, QTimer, QEventLoop
import os
from skimage.util import img_as_float
import numpy as np
from magicgui.widgets import FileEdit
from .utils import *
from scipy.ndimage import gaussian_filter
from skimage.feature import peak_local_max
import napari
import re
import json
import inspect
import skimage

if TYPE_CHECKING:
    import napari

class Parabola(QWidget):

    def __init__(self, napari_viewer):
        super().__init__()

        # Add viewer
        self.viewer = napari_viewer

        # Create the layout
        self.layout = QVBoxLayout()

        self.Z_label = QLabel("Z:")
        self.Z_input = QDoubleSpinBox(self)
        self.Z_input.setMinimum(0)
        self.Z_input.setMaximum(999999)
        self.Z_input.setValue(110)
        self.layout.addWidget(self.Z_label)
        self.layout.addWidget(self.Z_input)

        self.Y_label = QLabel("Y:")
        self.Y_input = QDoubleSpinBox(self)
        self.Y_input.setMinimum(0)
        self.Y_input.setMaximum(999999)
        self.Y_input.setValue(1100)
        self.layout.addWidget(self.Y_label)
        self.layout.addWidget(self.Y_input)

        self.X_label = QLabel("X:")
        self.X_input = QDoubleSpinBox(self)
        self.X_input.setMinimum(0)
        self.X_input.setMaximum(999999)
        self.X_input.setValue(1200)
        self.layout.addWidget(self.X_label)
        self.layout.addWidget(self.X_input)

        self.R_label = QLabel("R:")
        self.R_input = QDoubleSpinBox(self)
        self.R_input.setMinimum(0)
        self.R_input.setMaximum(999999)
        self.R_input.setValue(110)
        self.layout.addWidget(self.R_label)
        self.layout.addWidget(self.R_input)

        self.browse_button = QPushButton("Make Parabola")
        self.layout.addWidget(self.browse_button)
        self.browse_button.clicked.connect(self.compute)

        # Set the layout
        self.setLayout(self.layout)

    def compute(self):

        X,Y = np.meshgrid(np.arange(0,2300,10),np.arange(0,2300,10))
        X = X.flatten()
        Y = Y.flatten()
        Z = -((X-self.X_input.value())/self.R_input.value())**2-((Y-self.Y_input.value())/self.R_input.value())**2+self.Z_input.value()

        parabola = np.array([Z,Y,X]).transpose()

        if "Parabola" in self.viewer.layers:
            self.viewer.layers["Parabola"].data = parabola
        else:
            self.viewer.add_points(parabola, scale=(2,0.347,0.347), blending="translucent_no_depth", opacity=0.1, name="Parabola")

class Box(QWidget):

    def __init__(self, napari_viewer):
        super().__init__()

        # Add viewer
        self.viewer = napari_viewer

        # Create the layout
        self.layout = QVBoxLayout()

        self.Zmin_label = QLabel("Zmin:")
        self.Zmin_input = QDoubleSpinBox(self)
        self.Zmin_input.setMinimum(0)
        self.Zmin_input.setMaximum(999999)
        self.Zmin_input.setValue(0)
        self.layout.addWidget(self.Zmin_label)
        self.layout.addWidget(self.Zmin_input)

        self.Zmax_label = QLabel("Zmax:")
        self.Zmax_input = QDoubleSpinBox(self)
        self.Zmax_input.setMinimum(0)
        self.Zmax_input.setMaximum(999999)
        self.Zmax_input.setValue(300)
        self.layout.addWidget(self.Zmax_label)
        self.layout.addWidget(self.Zmax_input)

        self.Ymin_label = QLabel("Ymin:")
        self.Ymin_input = QDoubleSpinBox(self)
        self.Ymin_input.setMinimum(0)
        self.Ymin_input.setMaximum(999999)
        self.Ymin_input.setValue(0)
        self.layout.addWidget(self.Ymin_label)
        self.layout.addWidget(self.Ymin_input)

        self.Ymax_label = QLabel("Ymax:")
        self.Ymax_input = QDoubleSpinBox(self)
        self.Ymax_input.setMinimum(0)
        self.Ymax_input.setMaximum(999999)
        self.Ymax_input.setValue(2300)
        self.layout.addWidget(self.Ymax_label)
        self.layout.addWidget(self.Ymax_input)

        self.Xmin_label = QLabel("Xmin:")
        self.Xmin_input = QDoubleSpinBox(self)
        self.Xmin_input.setMinimum(0)
        self.Xmin_input.setMaximum(999999)
        self.Xmin_input.setValue(0)
        self.layout.addWidget(self.Xmin_label)
        self.layout.addWidget(self.Xmin_input)

        self.Xmax_label = QLabel("Xmax:")
        self.Xmax_input = QDoubleSpinBox(self)
        self.Xmax_input.setMinimum(0)
        self.Xmax_input.setMaximum(999999)
        self.Xmax_input.setValue(2300)
        self.layout.addWidget(self.Xmax_label)
        self.layout.addWidget(self.Xmax_input)

        self.browse_button = QPushButton("Make Box")
        self.layout.addWidget(self.browse_button)
        self.browse_button.clicked.connect(self.compute)

        # Set the layout
        self.setLayout(self.layout)

    def compute(self):

        X,Y = np.meshgrid(np.arange(self.Xmin_input.value(),self.Xmax_input.value(),10),np.arange(self.Ymin_input.value(),self.Ymax_input.value(),10))
        X = X.flatten()
        Y = Y.flatten()
        Z = np.zeros_like(X)
        cube = np.array([Z + self.Zmin_input.value(),Y,X]).transpose()
        cube = np.append(cube,np.array([Z + self.Zmax_input.value(),Y,X]).transpose(),axis=0)

        X,Z = np.meshgrid(np.arange(self.Xmin_input.value(),self.Xmax_input.value(),10),np.arange(self.Zmin_input.value(),self.Zmax_input.value(),10))
        X = X.flatten()
        Z = Z.flatten()
        Y = np.zeros_like(X)
        cube = np.append(cube,np.array([Z, Y + self.Ymin_input.value(),X]).transpose(),axis=0)
        cube = np.append(cube,np.array([Z, Y + self.Ymax_input.value(),X]).transpose(),axis=0)

        Y,Z = np.meshgrid(np.arange(self.Ymin_input.value(),self.Ymax_input.value(),10),np.arange(self.Zmin_input.value(),self.Zmax_input.value(),10))
        Y = Y.flatten()
        Z = Z.flatten()
        X = np.zeros_like(Y)
        cube = np.append(cube,np.array([Z, Y, X + self.Xmin_input.value()]).transpose(),axis=0)
        cube = np.append(cube,np.array([Z, Y, X + self.Xmax_input.value()]).transpose(),axis=0)

        if "Box" in self.viewer.layers:
            self.viewer.layers["Box"].data = cube
        else:
            self.viewer.add_points(cube, scale=(2,0.347,0.347), blending="translucent_no_depth", opacity=0.1, name="Box")

class BaseSavePath(QWidget):
    def __init__(self, napari_viewer):
        super().__init__()

        # Folder input for storing the JSON file
        self.folder_label = QLabel("Path to where to save project:")
        self.folder_input = QLineEdit(self)
        self.browse_folder_button = QPushButton("Browse Folder")
        self.browse_folder_button.clicked.connect(self.browse_json_folder)
        self.layout.addWidget(self.folder_label)
        self.layout.addWidget(self.folder_input)
        self.layout.addWidget(self.browse_folder_button)

        # Save button
        self.exec_button = QPushButton("Create tracking project")
        self.exec_button.clicked.connect(self.exec_function)
        self.layout.addWidget(self.exec_button)

        # Set the layout
        self.setLayout(self.layout)

        # Internal variable to store the number of files
        self.file_count = 0

    def browse_json_folder(self):
        """Open a file dialog to select a folder to save JSON."""
        folder_path = QFileDialog.getExistingDirectory(self, "Select Project")
        if folder_path:
            self.folder_input.setText(folder_path)

    def exec_function(self):
        print("Empty function")
        return
class BaseSetUp(QWidget):
    def __init__(self, napari_viewer):
        super().__init__()

        # Add viewer
        self.viewer = napari_viewer

        # Create the layout
        self.layout = QVBoxLayout()

        # Path input
        self.path_label = QLabel("Path to Data Folder:")
        self.path_input = QLineEdit(self)
        self.browse_button = QPushButton("Browse Folder")
        self.browse_button.clicked.connect(self.browse_folder)
        self.layout.addWidget(self.path_label)
        self.layout.addWidget(self.path_input)
        self.layout.addWidget(self.browse_button)

        # Start and end points
        self.start_label = QLabel("Start Point:")
        self.start_input = QSpinBox(self)
        self.start_input.setMinimum(0)
        self.start_input.setMaximum(999999)
        self.end_label = QLabel("End Point:")
        self.end_input = QSpinBox(self)
        self.end_input.setMinimum(0)
        self.end_input.setMaximum(999999)
        self.layout.addWidget(self.start_label)
        self.layout.addWidget(self.start_input)
        self.layout.addWidget(self.end_label)
        self.layout.addWidget(self.end_input)

        # Format input
        self.format_label = QLabel("Format:")
        self.format_input = QLineEdit(self)
        self.layout.addWidget(self.format_label)
        self.layout.addWidget(self.format_input)

        # Voxel sizes
        self.voxel_x_label = QLabel("Voxel X:")
        self.voxel_x_input = QDoubleSpinBox(self)
        self.voxel_x_input.setDecimals(3)
        self.voxel_x_input.setValue(0.347)
        self.voxel_x_input.setSingleStep(0.001)
        self.voxel_y_label = QLabel("Voxel Y:")
        self.voxel_y_input = QDoubleSpinBox(self)
        self.voxel_y_input.setDecimals(3)
        self.voxel_y_input.setValue(0.347)
        self.voxel_y_input.setSingleStep(0.001)
        self.voxel_z_label = QLabel("Voxel Z:")
        self.voxel_z_input = QDoubleSpinBox(self)
        self.voxel_z_input.setDecimals(3)
        self.voxel_z_input.setValue(2.0)
        self.voxel_z_input.setSingleStep(0.001)
        self.layout.addWidget(self.voxel_x_label)
        self.layout.addWidget(self.voxel_x_input)
        self.layout.addWidget(self.voxel_y_label)
        self.layout.addWidget(self.voxel_y_input)
        self.layout.addWidget(self.voxel_z_label)
        self.layout.addWidget(self.voxel_z_input)

        # Set the layout
        self.setLayout(self.layout)

        # Internal variable to store the number of files
        self.file_count = 0

    def browse_folder(self):
        """Open a file dialog to browse for a folder and count the number of files."""
        folder_path = QFileDialog.getExistingDirectory(self, "Select Data Folder")
        if folder_path:
            self.path_input.setText(folder_path)
            self.count_files_in_folder(folder_path)
            self.detect_file_pattern(folder_path)

    def count_files_in_folder(self, folder_path):
        """Count the number of files in the selected folder and set the start and end points."""
        try:
            file_list = os.listdir(folder_path)
            self.file_count = len(file_list)
        except Exception as e:
            print(f"Error counting files: {e}")

    def detect_file_pattern(self, folder_path):
        """Detect the file naming pattern, start and end points, and suggest it as the format."""
        try:
            file_list = os.listdir(folder_path)
            file_list = [f for f in file_list if os.path.isfile(os.path.join(folder_path, f))]
            file_list.sort()  # Ensure the files are sorted correctly

            if len(file_list) < 2:
                return  # We need at least two files to detect a pattern

            # Prepare to capture numeric patterns and invalid files
            num_pattern = re.compile(r'\d+')
            valid_files = []
            numeric_values = []
            format_str = None

            for file_name in file_list:
                match = num_pattern.search(file_name)
                if match:
                    valid_files.append(file_name)
                    numeric_values.append(int(match.group(0)))
                else:
                    print(f"File {file_name} does not follow the numeric pattern and will be skipped.")

            if len(valid_files) < 2:
                print("Not enough valid files to detect a pattern.")
                return

            # Compare first and last valid filenames
            file_1, file_2 = valid_files[0], valid_files[-1]
            format_str_parts = []
            i = 0

            while i < len(file_1):
                if i < len(file_2) and file_1[i] == file_2[i]:
                    format_str_parts.append(file_1[i])
                elif num_pattern.match(file_1[i:]):
                    num_match_1 = num_pattern.match(file_1[i:])
                    num_match_2 = num_pattern.match(file_2[i:])
                    if num_match_1 and num_match_2:
                        length_1 = len(num_match_1.group(0))
                        length_2 = len(num_match_2.group(0))
                        if length_1 == length_2:
                            format_str_parts.append(f"{{:0{length_1}d}}")
                            i += length_1 - 1  # Skip the numeric section
                        else:
                            format_str_parts.append(file_1[i])
                else:
                    format_str_parts.append(file_1[i])
                i += 1

            # Join format string and update the format input
            format_str = ''.join(format_str_parts)
            self.format_input.setText(format_str)

            # Set start and end points based on detected numeric sequence
            if numeric_values:
                self.start_input.setValue(min(numeric_values))
                self.end_input.setValue(max(numeric_values))

        except Exception as e:
            print(f"Error detecting file pattern: {e}")

class LoadSample(BaseSetUp):
    def __init__(self, napari_viewer):
        super().__init__(napari_viewer)

        # Steps
        self.step_label = QLabel("Steps:")
        self.step_input = QSpinBox(self)
        self.step_input.setMinimum(-1)
        self.step_input.setMaximum(999999)
        self.step_input.setValue(-1)
        self.layout.addWidget(self.step_label)
        self.layout.addWidget(self.step_input)

        # Maximum
        self.maxproj_checkbox = QCheckBox("Max projection")
        self.maxproj_checkbox.setChecked(True)
        self.layout.addWidget(self.maxproj_checkbox)

        # Save button
        self.exec_button = QPushButton("Load Sample")
        self.exec_button.clicked.connect(self.exec_function)
        self.layout.addWidget(self.exec_button)

        # Set the layout
        self.setLayout(self.layout)

    def exec_function(self):

        path = self.path_input.text()
        if self.step_input.value() == -1:
            l = [0, self.end_input.value()]
        else:
            l = range(self.start_input.value(), self.end_input.value(), self.step_input.value())

        file = self.format_input.text().format(l[0])
        img = skimage.io.imread("{}/{}".format(path,file))
        for i in l:
            file = self.format_input.text().format(i)
            img = np.maximum(skimage.io.imread("{}/{}".format(path,file)), img)
        
        scale = (self.voxel_z_input.value(),self.voxel_y_input.value(),self.voxel_x_input.value())
        self.viewer.add_image(img,scale=scale,colormap="red",opacity=1)
        
        return
    
class SetUpTracking(BaseSetUp, BaseSavePath):
    def __init__(self, napari_viewer):
        BaseSetUp.__init__(self,napari_viewer)
        BaseSavePath.__init__(self,napari_viewer)

    def exec_function(self):
        """Save the current input to a JSON file in the selected folder and create NumPy files for points and tracking layers."""
        settings = {
            'path_data': self.path_input.text(),
            'start_point': self.start_input.value(),
            'end_point': self.end_input.value(),
            'format_str': self.format_input.text(),
            'voxel_x': self.voxel_x_input.value(),
            'voxel_y': self.voxel_y_input.value(),
            'voxel_z': self.voxel_z_input.value(),
        }
        
        folder_path = self.folder_input.text()
        if folder_path:
            # Check if folder is empty
            if os.listdir(folder_path):  # Folder is not empty
                reply = QMessageBox.question(
                    self, 
                    'Folder Not Empty', 
                    "The selected folder is not empty. Do you want to overwrite the contents?",
                    QMessageBox.Yes | QMessageBox.No, 
                    QMessageBox.No
                )

                if reply == QMessageBox.No:
                    return  # Do not proceed with saving
                # If user clicks "Yes", proceed with the saving process

            # Define file paths
            settings_file_path = os.path.join(folder_path, 'settings.json')
            points_file_path = os.path.join(folder_path, 'points.npy')
            points_id_file_path = os.path.join(folder_path, 'points_id.npy')
            trackings_file_path = os.path.join(folder_path, 'trackings.npy')
            
            try:
                # Save settings.json
                with open(settings_file_path, 'w') as settings_file:
                    json.dump(settings, settings_file, indent=4)

                # Create empty points.npy (for storing points layers later)
                points_array = np.empty((0, 4))  # Assuming points are in 3D, create an empty array
                np.save(points_file_path, points_array)

                # Create empty points.npy (for storing points layers later)
                points_id_array = np.empty((0))  # Assuming points are in 3D, create an empty array
                np.save(points_id_file_path, points_id_array)

                # Create empty trackings.npy (for storing tracking layers later)
                trackings_array = np.empty((0, 5))  # Assuming trackings are in 3D, create an empty array
                np.save(trackings_file_path, trackings_array)

                print(f"Settings saved to {settings_file_path}")
                print(f"Empty points.npy and trackings.npy created in {folder_path}")
            except Exception as e:
                print(f"Error saving files: {e}")
        else:
            print("No folder selected for saving.")

class SetUpTrackingDialog(QDialog):
    def __init__(self, napari_viewer):
        super().__init__()

        # Add viewer
        self.viewer = napari_viewer

        # Create the layout
        self.layout = QVBoxLayout()

        # Path input
        self.path_label = QLabel("Path to Data Folder:")
        self.path_input = QLineEdit(self)
        self.browse_button = QPushButton("Browse Folder")
        self.browse_button.clicked.connect(self.browse_folder)
        self.layout.addWidget(self.path_label)
        self.layout.addWidget(self.path_input)
        self.layout.addWidget(self.browse_button)

        # Start and end points
        self.start_label = QLabel("Start Point:")
        self.start_input = QSpinBox(self)
        self.start_input.setMinimum(0)
        self.start_input.setMaximum(999999)
        self.end_label = QLabel("End Point:")
        self.end_input = QSpinBox(self)
        self.end_input.setMinimum(0)
        self.end_input.setMaximum(999999)
        self.layout.addWidget(self.start_label)
        self.layout.addWidget(self.start_input)
        self.layout.addWidget(self.end_label)
        self.layout.addWidget(self.end_input)

        # Format input
        self.format_label = QLabel("Format:")
        self.format_input = QLineEdit(self)
        self.layout.addWidget(self.format_label)
        self.layout.addWidget(self.format_input)

        # Voxel sizes
        self.voxel_x_label = QLabel("Voxel X:")
        self.voxel_x_input = QDoubleSpinBox(self)
        self.voxel_x_input.setDecimals(3)
        self.voxel_x_input.setValue(0.347)
        self.voxel_x_input.setSingleStep(0.001)
        self.voxel_y_label = QLabel("Voxel Y:")
        self.voxel_y_input = QDoubleSpinBox(self)
        self.voxel_y_input.setDecimals(3)
        self.voxel_y_input.setValue(0.347)
        self.voxel_y_input.setSingleStep(0.001)
        self.voxel_z_label = QLabel("Voxel Z:")
        self.voxel_z_input = QDoubleSpinBox(self)
        self.voxel_z_input.setDecimals(3)
        self.voxel_z_input.setValue(2.0)
        self.voxel_z_input.setSingleStep(0.001)
        self.layout.addWidget(self.voxel_x_label)
        self.layout.addWidget(self.voxel_x_input)
        self.layout.addWidget(self.voxel_y_label)
        self.layout.addWidget(self.voxel_y_input)
        self.layout.addWidget(self.voxel_z_label)
        self.layout.addWidget(self.voxel_z_input)

        # Folder input for storing the JSON file
        self.folder_label = QLabel("Path to where to save project:")
        self.folder_input = QLineEdit(self)
        self.browse_folder_button = QPushButton("Browse Folder")
        self.browse_folder_button.clicked.connect(self.browse_json_folder)
        self.layout.addWidget(self.folder_label)
        self.layout.addWidget(self.folder_input)
        self.layout.addWidget(self.browse_folder_button)

        # Save button
        self.save_button = QPushButton("Create tracking project")
        self.save_button.clicked.connect(self.save_to_json)
        self.layout.addWidget(self.save_button)

        # Set the layout
        self.setLayout(self.layout)

        # Internal variable to store the number of files
        self.file_count = 0

    def browse_folder(self):
        """Open a file dialog to browse for a folder and count the number of files."""
        folder_path = QFileDialog.getExistingDirectory(self, "Select Data Folder")
        if folder_path:
            self.path_input.setText(folder_path)
            self.count_files_in_folder(folder_path)
            self.detect_file_pattern(folder_path)

    def browse_json_folder(self):
        """Open a file dialog to select a folder to save JSON."""
        folder_path = QFileDialog.getExistingDirectory(self, "Select Project")
        if folder_path:
            self.folder_input.setText(folder_path)

    def count_files_in_folder(self, folder_path):
        """Count the number of files in the selected folder and set the start and end points."""
        try:
            file_list = os.listdir(folder_path)
            self.file_count = len(file_list)
        except Exception as e:
            print(f"Error counting files: {e}")

    def detect_file_pattern(self, folder_path):
        """Detect the file naming pattern, start and end points, and suggest it as the format."""
        try:
            file_list = os.listdir(folder_path)
            file_list = [f for f in file_list if os.path.isfile(os.path.join(folder_path, f))]
            file_list.sort()  # Ensure the files are sorted correctly

            if len(file_list) < 2:
                return  # We need at least two files to detect a pattern

            # Prepare to capture numeric patterns and invalid files
            num_pattern = re.compile(r'\d+')
            valid_files = []
            numeric_values = []
            format_str = None

            for file_name in file_list:
                match = num_pattern.search(file_name)
                if match:
                    valid_files.append(file_name)
                    numeric_values.append(int(match.group(0)))
                else:
                    print(f"File {file_name} does not follow the numeric pattern and will be skipped.")

            if len(valid_files) < 2:
                print("Not enough valid files to detect a pattern.")
                return

            # Compare first and last valid filenames
            file_1, file_2 = valid_files[0], valid_files[-1]
            format_str_parts = []
            i = 0

            while i < len(file_1):
                if i < len(file_2) and file_1[i] == file_2[i]:
                    format_str_parts.append(file_1[i])
                elif num_pattern.match(file_1[i:]):
                    num_match_1 = num_pattern.match(file_1[i:])
                    num_match_2 = num_pattern.match(file_2[i:])
                    if num_match_1 and num_match_2:
                        length_1 = len(num_match_1.group(0))
                        length_2 = len(num_match_2.group(0))
                        if length_1 == length_2:
                            format_str_parts.append(f"{{:0{length_1}d}}")
                            i += length_1 - 1  # Skip the numeric section
                        else:
                            format_str_parts.append(file_1[i])
                else:
                    format_str_parts.append(file_1[i])
                i += 1

            # Join format string and update the format input
            format_str = ''.join(format_str_parts)
            self.format_input.setText(format_str)

            # Set start and end points based on detected numeric sequence
            if numeric_values:
                self.start_input.setValue(min(numeric_values))
                self.end_input.setValue(max(numeric_values))

        except Exception as e:
            print(f"Error detecting file pattern: {e}")

    def save_to_json(self):
        """Save the current input to a JSON file in the selected folder and create NumPy files for points and tracking layers."""
        settings = {
            'path_data': self.path_input.text(),
            'start_point': self.start_input.value(),
            'end_point': self.end_input.value(),
            'format_str': self.format_input.text(),
            'voxel_x': self.voxel_x_input.value(),
            'voxel_y': self.voxel_y_input.value(),
            'voxel_z': self.voxel_z_input.value(),
        }
        
        folder_path = self.folder_input.text()
        if folder_path:
            # Check if folder is empty
            if os.listdir(folder_path):  # Folder is not empty
                reply = QMessageBox.question(
                    self, 
                    'Folder Not Empty', 
                    "The selected folder is not empty. Do you want to overwrite the contents?",
                    QMessageBox.Yes | QMessageBox.No, 
                    QMessageBox.No
                )

                if reply == QMessageBox.No:
                    return  # Do not proceed with saving
                # If user clicks "Yes", proceed with the saving process

            # Define file paths
            settings_file_path = os.path.join(folder_path, 'settings.json')
            points_file_path = os.path.join(folder_path, 'points.npy')
            points_id_file_path = os.path.join(folder_path, 'points_id.npy')
            trackings_file_path = os.path.join(folder_path, 'trackings.npy')
            
            try:
                # Save settings.json
                with open(settings_file_path, 'w') as settings_file:
                    json.dump(settings, settings_file, indent=4)

                # Create empty points.npy (for storing points layers later)
                points_array = np.empty((0, 4))  # Assuming points are in 3D, create an empty array
                np.save(points_file_path, points_array)

                # Create empty points.npy (for storing points layers later)
                points_id_array = np.empty((0))  # Assuming points are in 3D, create an empty array
                np.save(points_id_file_path, points_id_array)

                # Create empty trackings.npy (for storing tracking layers later)
                trackings_array = np.empty((0, 5))  # Assuming trackings are in 3D, create an empty array
                np.save(trackings_file_path, trackings_array)

                print(f"Settings saved to {settings_file_path}")
                print(f"Empty points.npy and trackings.npy created in {folder_path}")
            except Exception as e:
                print(f"Error saving files: {e}")
        else:
            print("No folder selected for saving.")

        self.accept()

class LoadTracking(QWidget):
    def __init__(self, napari_viewer):
        super().__init__()

        # Add napari viewer
        self.viewer = napari_viewer

        # Create the layout
        self.layout = QVBoxLayout()

        # Folder selection input
        self.folder_label = QLabel("Select Project Folder:")
        self.folder_input = QLineEdit(self)
        self.browse_folder_button = QPushButton("Browse Folder")
        self.browse_folder_button.clicked.connect(self.browse_folder)
        self.layout.addWidget(self.folder_label)
        self.layout.addWidget(self.folder_input)
        self.layout.addWidget(self.browse_folder_button)

        # Layer checkboxes (default all checked)
        self.data_checkbox = QCheckBox("Data")
        self.data_checkbox.setChecked(True)
        self.layout.addWidget(self.data_checkbox)

        self.points_checkbox = QCheckBox("Points")
        self.points_checkbox.setChecked(True)
        self.layout.addWidget(self.points_checkbox)

        self.tracking_checkbox = QCheckBox("Tracking")
        self.tracking_checkbox.setChecked(True)
        self.layout.addWidget(self.tracking_checkbox)

        # Load button
        self.load_button = QPushButton("Load Layers")
        self.load_button.clicked.connect(self.load_layers)
        self.layout.addWidget(self.load_button)

        # Set the layout
        self.setLayout(self.layout)

    def browse_folder(self):
        """Open a file dialog to browse for the project folder."""
        folder_path = QFileDialog.getExistingDirectory(self, "Select Project Folder")
        if folder_path:
            self.folder_input.setText(folder_path)

    def load_layers(self):
        """Load the selected layers based on user input."""
        folder_path = self.folder_input.text()

        # Ensure the folder path is valid
        if not os.path.exists(folder_path):
            print("Invalid folder path.")
            return

        # Load settings from settings.json
        settings_file = os.path.join(folder_path, "settings.json")
        if not os.path.exists(settings_file):
            print("settings.json not found.")
            return

        try:
            with open(settings_file, 'r') as f:
                settings = json.load(f)
        except Exception as e:
            print(f"Error loading settings.json: {e}")
            return

        voxel_x = settings.get('voxel_x', 1.0)
        voxel_y = settings.get('voxel_y', 1.0)
        voxel_z = settings.get('voxel_z', 1.0)
        scale = [voxel_z, voxel_y, voxel_x]

        # Load the selected layers
        if self.data_checkbox.isChecked():
            self.load_data_layer(folder_path, settings, scale)

        if self.points_checkbox.isChecked():
            self.load_points_layer(folder_path, scale)

        if self.tracking_checkbox.isChecked():
            self.load_tracking_layer(folder_path, scale)

    def load_data_layer(self, folder_path, settings, scale):
        """Load the data layer from the project folder."""
        try:
            # Assuming read_split_times is defined elsewhere
            path_data = settings['path_data']
            start_point = settings['start_point']
            end_point = settings['end_point']
            format_str = settings['format_str']
            
            # Load the movie/data layer
            image = read_split_times(
                str(path_data),
                range(start_point, end_point + 1),
                format_str
            )[0][:, :, 0, :, :]
            
            # Add the image layer to the viewer
            self.viewer.add_image(image, scale=scale, name="Data Layer", metadata={"path":str(folder_path)})
            print("Data layer loaded successfully.")
        except Exception as e:
            print(f"Error loading data layer: {e}")

    def load_points_layer(self, folder_path, scale):
        """Load the points layer from points.npy, even if it's empty."""
        points_file = os.path.join(folder_path, "points.npy")
        points = np.empty((0, 4))  # Default empty points array in 3D

        points_id_file = os.path.join(folder_path, "points_id.npy")
        points_id = np.empty((0))  # Default empty points array in 3D

        if os.path.exists(points_file):
            try:
                points = np.load(points_file)
                points_id = np.load(points_id_file)
            except Exception as e:
                print(f"Error loading points layer: {e}")

        # Add points layer to Napari viewer (even if empty)
        self.viewer.add_points(points, properties={'id':points_id}, scale=np.append([1],scale), name="Points Layer", metadata={"path":str(folder_path)})
        print("Points layer (empty or not) loaded successfully.")

    def load_tracking_layer(self, folder_path, scale):
        """Load the tracking layer from trackings.npy, even if it's empty."""
        tracking_file = os.path.join(folder_path, "trackings.npy")

        if os.path.exists(tracking_file):
            try:
                trackings = np.load(tracking_file)
            except Exception as e:
                print(f"Error loading tracking layer: {e}")

        if len(trackings) == 0:
            trackings = np.zeros((1, 5))  # Default empty tracks array

        # Add tracks layer to Napari viewer (even if empty)
        # self.viewer.add_tracks(trackings, scale=np.append([1,1],scale), name="Tracking Layer")
        self.viewer.add_tracks(trackings, name="Tracking Layer", scale=np.append([1],scale), metadata={"path":str(folder_path)})
        print("Tracking layer (empty or not) loaded successfully.")

class LoadTrackingDialog(QDialog):
    def __init__(self, napari_viewer):
        super().__init__()

        # Add napari viewer
        self.viewer = napari_viewer

        # Create the layout
        self.layout = QVBoxLayout()

        # Folder selection input
        self.folder_label = QLabel("Select Project Folder:")
        self.folder_input = QLineEdit(self)
        self.browse_folder_button = QPushButton("Browse Folder")
        self.browse_folder_button.clicked.connect(self.browse_folder)
        self.layout.addWidget(self.folder_label)
        self.layout.addWidget(self.folder_input)
        self.layout.addWidget(self.browse_folder_button)

        # Layer checkboxes (default all checked)
        self.data_checkbox = QCheckBox("Data")
        self.data_checkbox.setChecked(True)
        self.layout.addWidget(self.data_checkbox)

        self.points_checkbox = QCheckBox("Points")
        self.points_checkbox.setChecked(True)
        self.layout.addWidget(self.points_checkbox)

        self.tracking_checkbox = QCheckBox("Tracking")
        self.tracking_checkbox.setChecked(True)
        self.layout.addWidget(self.tracking_checkbox)

        # Load button
        self.load_button = QPushButton("Load Layers")
        self.load_button.clicked.connect(self.load_layers)
        self.layout.addWidget(self.load_button)

        # Set the layout
        self.setLayout(self.layout)

    def browse_folder(self):
        """Open a file dialog to browse for the project folder."""
        folder_path = QFileDialog.getExistingDirectory(self, "Select Project Folder")
        if folder_path:
            self.folder_input.setText(folder_path)

    def load_layers(self):
        """Load the selected layers based on user input."""
        folder_path = self.folder_input.text()

        # Ensure the folder path is valid
        if not os.path.exists(folder_path):
            print("Invalid folder path.")
            return

        # Load settings from settings.json
        settings_file = os.path.join(folder_path, "settings.json")
        if not os.path.exists(settings_file):
            print("settings.json not found.")
            return

        try:
            with open(settings_file, 'r') as f:
                settings = json.load(f)
        except Exception as e:
            print(f"Error loading settings.json: {e}")
            return

        voxel_x = settings.get('voxel_x', 1.0)
        voxel_y = settings.get('voxel_y', 1.0)
        voxel_z = settings.get('voxel_z', 1.0)
        scale = [voxel_z, voxel_y, voxel_x]

        # Load the selected layers
        if self.data_checkbox.isChecked():
            self.load_data_layer(folder_path, settings, scale)

        if self.points_checkbox.isChecked():
            self.load_points_layer(folder_path, scale)

        if self.tracking_checkbox.isChecked():
            self.load_tracking_layer(folder_path, scale)

        self.accept()

    def load_data_layer(self, folder_path, settings, scale):
        """Load the data layer from the project folder."""
        try:
            # Assuming read_split_times is defined elsewhere
            path_data = settings['path_data']
            start_point = settings['start_point']
            end_point = settings['end_point']
            format_str = settings['format_str']
            
            # Load the movie/data layer
            image = read_split_times(
                str(path_data),
                range(start_point, end_point + 1),
                format_str
            )[0][:, :, 0, :, :]
            
            # Add the image layer to the viewer
            self.viewer.add_image(image, scale=scale, name="Data Layer", metadata={"path":str(folder_path)})
            print("Data layer loaded successfully.")
        except Exception as e:
            print(f"Error loading data layer: {e}")

    def load_points_layer(self, folder_path, scale):
        """Load the points layer from points.npy, even if it's empty."""
        points_file = os.path.join(folder_path, "points.npy")
        points = np.empty((0, 4))  # Default empty points array in 3D

        points_id_file = os.path.join(folder_path, "points_id.npy")
        points_id = np.empty((0))  # Default empty points array in 3D

        if os.path.exists(points_file):
            try:
                points = np.load(points_file)
                points_id = np.load(points_id_file)
            except Exception as e:
                print(f"Error loading points layer: {e}")

        # Add points layer to Napari viewer (even if empty)
        self.viewer.add_points(points, properties={'id':points_id}, scale=np.append([1],scale), name="Points Layer", metadata={"path":str(folder_path)})
        print("Points layer (empty or not) loaded successfully.")

    def load_tracking_layer(self, folder_path, scale):
        """Load the tracking layer from trackings.npy, even if it's empty."""
        tracking_file = os.path.join(folder_path, "trackings.npy")

        if os.path.exists(tracking_file):
            try:
                trackings = np.load(tracking_file)
            except Exception as e:
                print(f"Error loading tracking layer: {e}")

        if len(trackings) == 0:
            trackings = np.zeros((1, 5))  # Default empty tracks array

        # Add tracks layer to Napari viewer (even if empty)
        # self.viewer.add_tracks(trackings, scale=np.append([1,1],scale), name="Tracking Layer")
        self.viewer.add_tracks(trackings, name="Tracking Layer", scale=np.append([1],scale), metadata={"path":str(folder_path)})
        print("Tracking layer (empty or not) loaded successfully.")

class ManualTracking(QWidget):
    def __init__(self, napari_viewer):
        super().__init__()

        # Add napari viewer
        self.viewer = napari_viewer

        while 'Data Layer' not in napari_viewer.layers or \
            'Points Layer' not in napari_viewer.layers or \
            'Tracking Layer' not in napari_viewer.layers:

            msg = QMessageBox()
            msg.setWindowTitle("Layers missing")
            msg.setText("Files from a tracking project seems to be missing.")
            msg.setIcon(QMessageBox.Question)

            # Add more than two buttons
            button_create = msg.addButton("Create one", QMessageBox.ActionRole)
            button_load = msg.addButton("Load one", QMessageBox.ActionRole)

            msg.exec_()

            if msg.clickedButton() == button_create:
                load_tracking_dialog = SetUpTrackingDialog(napari_viewer)
                load_tracking_dialog.exec_()
            elif msg.clickedButton() == button_load:
                load_tracking_dialog = LoadTrackingDialog(napari_viewer)
                load_tracking_dialog.exec_()

        # Create the layout
        self.layout = QVBoxLayout()

        # Add checkbox for manual tracking activation/deactivation
        self.click_3D = QCheckBox("3D clicking")
        self.click_3D.setChecked(True)
        self.layout.addWidget(self.click_3D)

        # Add checkbox for manual tracking activation/deactivation
        self.rotate_3D = QCheckBox("3D automatic rotation")
        self.rotate_3D.setChecked(True)
        self.layout.addWidget(self.rotate_3D)
        self.current_angle = None
        self.target_angle = None
        self.current_frame = 0
        self.point1_angle = None
        self.point2_angle = None
        self.timer = None

        # Store references to new layers added (for easy removal)
        self.image_layer = self.viewer.layers['Data Layer']
        self.points_layer = self.viewer.layers['Points Layer']
        self.add = self.points_layer.add
        self.points_layer.add = self.add_points
        self.remove_selected = self.points_layer.remove_selected
        self.points_layer.remove_selected = self.remove
        self.tracking_layer = self.viewer.layers['Tracking Layer']
        self.length = len(self.image_layer.data)
        # self.points_layer.events.data.connect(self.on_point_added)
        self.viewer.mouse_drag_callbacks.append(self.connect_point)

        # Auxiliar connect
        self.image_layer_aux_forw = None
        self.image_layer_aux_back = None
        self.points_layer_aux_forw = None
        self.points_layer_aux_back = None
        self.process_image_layer_aux()
        self.process_points_layer_aux()

        # To store the two points and directions
        self.point1 = None
        self.direction1 = None
        self.point2 = None
        self.direction2 = None
        self.counter = 0

        self.prevent_update = False

        #Track
        self.tracking_forward = True
        self.tracking_active = False
        self.tracking_active_id = np.nan
        self.tracking_time = 0
        if np.all(self.tracking_layer.data == 0):
            self.tracking_max_id = 0
        else:
            self.tracking_max_id = np.max(self.viewer.layers['Tracking Layer'].data,axis=0)[0]
        self.start_tracking_button = QPushButton("Start Tracking")
        self.layout.addWidget(self.start_tracking_button)
        self.start_tracking_button.clicked.connect(self.new_tracking)
        self.stop_tracking_button = QPushButton("Stop Tracking")
        self.layout.addWidget(self.stop_tracking_button)
        self.stop_tracking_button.clicked.connect(self.stop_tracking)

        # Jump Next
        self.jump_next_checkBox = QCheckBox("Jump automatically to next image.")
        self.jump_next_checkBox.setChecked(True)
        self.layout.addWidget(self.jump_next_checkBox)

        # Debug
        self.debugging = QCheckBox("Debugging")
        self.debugging.setChecked(False)
        self.layout.addWidget(self.debugging)

        self.viewer.layers.selection.active = self.viewer.layers['Points Layer']

        # #Debug
        # self.vectorcheckbox = QCheckBox("Debug")
        # self.layout.addWidget(self.vectorcheckbox)
        # self.vectorcheckbox.stateChanged.connect(self.make_vector_layer)
        self.save_button = QPushButton("Save")
        self.layout.addWidget(self.save_button)
        self.save_button.clicked.connect(self.save)

        # Set the layout
        self.setLayout(self.layout)

        # Reorder
        self.viewer.layers["Data Layer"].opacity = 0.5
        self.viewer.layers.move_multiple(
            [
            4,3,2,1,0,5,6
            ]
        )

    def connect_point(self, *args):

        if False:
            print("Active and point selected")

    def hideEvent(self, event):
        """Triggered when the widget is hidden, disconnect the point added callback if active."""
        if self.points_layer is not None:
            # self.points_layer.events.data.disconnect(self.on_point_added)
            self.points_layer.remove_selected = self.remove_selected
            self.points_layer.add = self.add
        if self.image_layer_aux_forw is not None:
            self.viewer.layers.remove(self.image_layer_aux_forw)
        if self.image_layer_aux_back is not None:
            self.viewer.layers.remove(self.image_layer_aux_back)
        if self.points_layer_aux_forw is not None:
            self.viewer.layers.remove(self.points_layer_aux_forw)
        if self.points_layer_aux_back is not None:
            self.viewer.layers.remove(self.points_layer_aux_back)

        super().hideEvent(event)

    def process_image_layer_aux(self):
        """Process the image layer by adding an initial time of zeros and removing the last image, using a memory-efficient view."""
        # Check if 'Data Layer' exists in the viewer
        if 'Data Layer' in self.viewer.layers:
            original_image = self.viewer.layers['Data Layer'].data
            original_scale = self.viewer.layers['Data Layer'].scale  # Get original scale

            # Create a memory-efficient view by skipping the last frame of the original image
            view_image = original_image[:-1]  # This is a view, not a copy
            # Add an additional frame of zeros at the beginning without copying the entire array
            zero_frame = np.zeros_like(view_image[0:1])  # Just one frame of zeros
            new_image_forward = np.concatenate((zero_frame, view_image), axis=0)  # Combine with view
            # Add the new image layer with green color code, keeping the original scale
            self.image_layer_aux_forw = self.viewer.add_image(new_image_forward, colormap='green', name="Auxiliar Forward Image Layer", opacity=0.5, scale=original_scale, visible=False)

            # Create a memory-efficient view by skipping the last frame of the original image
            view_image = original_image[1:]  # This is a view, not a copy
            # Add an additional frame of zeros at the beginning without copying the entire array
            zero_frame = np.zeros_like(view_image[0:1])  # Just one frame of zeros
            new_image_backward = np.concatenate((view_image, zero_frame), axis=0)  # Combine with view
            # Add the new image layer with green color code, keeping the original scale
            self.image_layer_aux_back = self.viewer.add_image(new_image_backward, colormap='red', name="Auxiliar Backward Image Layer", opacity=0.5, scale=original_scale, visible=False)

        else:
            print("Data Layer not found in the viewer.")

    def process_points_layer_aux(self):
        """Process points layer by shifting time backward and applying green color and cross shape, using a memory-efficient view."""
        # Check if 'Points Layer' exists in the viewer
        if 'Points Layer' in self.viewer.layers:
            original_points = self.viewer.layers['Points Layer'].data
            original_scale = self.viewer.layers['Points Layer'].scale  # Get original scale

            # Create a view of the original points data and shift the time points backward
            modified_points_forw = original_points.copy()
            modified_points_forw[:, 0] += 1  # Assuming time is the first column
            modified_points_forw = modified_points_forw[modified_points_forw[:,0] < self.length]
            # Add the new points layer with green cross markers, keeping the original scale
            self.points_layer_aux_forw = self.viewer.add_points(modified_points_forw, size=8, face_color='green', symbol='cross', name="Auxiliar Forward Tracking Points", scale=original_scale, blending="translucent_no_depth", visible=False)

            # Create a view of the original points data and shift the time points backward
            modified_points_back = original_points.copy()
            modified_points_back[:, 0] -= 1  # Assuming time is the first column
            modified_points_back = modified_points_back[modified_points_back[:,0] >= 0]
            # Add the new points layer with green cross markers, keeping the original scale
            self.points_layer_aux_back = self.viewer.add_points(modified_points_back, size=8, face_color='red', symbol='cross', name="Auxiliar Backward Tracking Points", scale=original_scale, blending="translucent_no_depth", visible=False)

        else:
            print("Points Layer not found in the viewer.")

    def add_points(self, new_point):
        """Callback triggered when a new point is added to the points layer."""
        
        if 0 in self.viewer.dims.displayed:
            if self.debugging.isChecked():
                print("Some axis is not an spatial perspective. Ignoring point addition.")
            return
        
        if self.timer != None:
            return

        # Checking causality
        if self.tracking_active:

            if self.tracking_time+1 != self.get_time() and self.tracking_forward:    

                reply = QMessageBox.question(
                    self, 
                    'Forward trajectory causality broken', 
                    f"You are tracking and the time you are adding a point is not the immediate next point of the current tracking (last was {self.tracking_time}, current {self.get_time()}). Maybe you have changed the time and not gone back to the current tracking time point. Do you want to continue tracking?",
                    QMessageBox.Yes | QMessageBox.No, 
                    QMessageBox.No
                )

                if reply == QMessageBox.No:
                    self.stop_tracking()
                    return
                elif reply == QMessageBox.Yes:
                    self.viewer.dims.current_step = (self.tracking_time+1, *self.viewer.dims.current_step[1:])
                    return

            elif self.tracking_time-1 != self.get_time() and not self.tracking_forward:    

                reply = QMessageBox.question(
                    self, 
                    'Backward trajectory causality broken', 
                    f"You are tracking and the time you are adding a point is not the immediate next point of the current tracking (last was {self.tracking_time}, current {self.get_time()}). Maybe you have changed the time and not gone back to the current tracking time point. Do you want to continue tracking?",
                    QMessageBox.Yes | QMessageBox.No, 
                    QMessageBox.No
                )

                if reply == QMessageBox.No:
                    self.stop_tracking()
                    return
                elif reply == QMessageBox.Yes:
                    self.viewer.dims.current_step = (self.tracking_time-1, *self.viewer.dims.current_step[1:])
                    return

        # Add point in 2D or 3D
        if self.viewer.dims.ndisplay == 2:

            # Add tracking
            self.add(new_point)
            self.add_point_properties(self.points_layer)
            self.update_tracks_layer_with_new_point(new_point)
            #Add auxiliar
            self.add_point_auxiliar(new_point)

        elif self.viewer.dims.ndisplay == 3:

            # If it's the first point, store it and its direction
            if self.point1 is None:

                self.point1 = new_point
                self.direction1 = self.compute_camera_direction()  # Replace with your own logic to get direction
                if self.debugging.isChecked():
                    print(f"First point stored at: {self.point1}, direction: {self.direction1}")

                self.point1_angle = self.viewer.camera.angles
                if self.rotate_3D.isChecked() and self.point2_angle != None:
                    self.rotate_3D_animation(self.point2_angle)

                self.add(self.point1)

                return
            
            else:

                # If it's the second point, store it and calculate the closest point
                self.direction2 = self.compute_camera_direction()  # Replace with your own logic to get direction
                if self.debugging.isChecked():
                    print(f"Second point stored at: {self.point2}, direction: {self.direction2}")

                # Calculate the closest point between the two lines
                closest_point = self.calculate_closest_point(self.point1, self.direction1, new_point, self.direction2)
                if self.debugging.isChecked():
                    print(f"Closest point calculated at: {closest_point}")

                # Add closest
                self.points_layer.data = self.points_layer.data[:-1] 
                self.add(closest_point)
                self.update_tracks_layer_with_new_point(closest_point)

                #Add auxiliar
                self.add_point_auxiliar(closest_point)

                # # Update vectors layer with the vectors from points and directions
                # if self.vectorcheckbox.isChecked():
                #     self.update_vectors_layer()

                # Reset point storage for the next pair of points
                self.point1 = None

                self.point2_angle = self.viewer.camera.angles
                if self.rotate_3D.isChecked() and self.point1_angle != None:
                    self.rotate_3D_animation(self.point1_angle)

        if self.tracking_active:
            self.jump_next()

    def add_point_auxiliar(self, new_point):

        new_point[0] += 1
        if new_point[0] < self.length:
            self.points_layer_aux_forw.add(new_point)
        new_point[0] -= 2
        if new_point[0] >= 0:
            self.points_layer_aux_back.add(new_point)

    def remove(self):

        selected_pos = list(self.points_layer.selected_data)
        selected_id = self.points_layer.properties["id"][selected_pos]
        
        print(selected_id)
        if np.all(np.isnan(selected_id)):

            self.prevent_update = True
            self.remove_selected()
            self.prevent_update = False

        elif len(selected_pos) > 1:

            msg = QMessageBox()
            msg.setWindowTitle("Multiple deletions")
            msg.setText("We are preventing to remove several points at the same time. Just select one per deletion.")
            msg.setIcon(QMessageBox.Question)

            # Add more than two buttons
            button_forward = msg.addButton("Okay", QMessageBox.ActionRole)

            msg.exec_()

            return
        
        elif len(self.points_layer.selected_data) == 1:

            selected_point = self.points_layer.data[selected_pos[0]] 
            selected_id = self.points_layer.properties["id"][selected_pos[0]]
            
            msg = QMessageBox()
            msg.setWindowTitle("Point removal")
            msg.setText("Do you want to remove just this point or the whole track.")
            msg.setIcon(QMessageBox.Question)

            # Add more than two buttons
            button_point = msg.addButton("Remove Point", QMessageBox.ActionRole)
            button_track = msg.addButton("Remove Track", QMessageBox.ActionRole)
            button_cancel = msg.addButton("Cancel", QMessageBox.ActionRole)

            msg.exec_()

            if msg.clickedButton() == button_point:

                self.remove_track_point(selected_point, selected_id)

            elif msg.clickedButton() == button_track:

                self.remove_track(selected_point, selected_id)

            elif msg.clickedButton() == button_cancel:

                return

    def rotate_camera(self):
        # Calculate new position based on interpolation
        new_angle = (1 - self.current_frame / 6) * self.current_angle + (self.current_frame / 6) * self.target_angle
        
        # Update the camera's position (center)
        self.viewer.camera.angles = new_angle
        
        # Increment the frame counter
        self.current_frame += 1
                
        if self.current_frame >= 6:
            # Stop the timer when the final frame is reached
            self.timer.stop()
            self.loop.quit()  # Exit the event loop after completing the last frame
        else:
            # Continue the rotation by restarting the timer for the next frame
            self.timer.start(0)  # 30 milliseconds per frame

    def rotate_3D_animation(self, target_angle):

        self.viewer.camera.interactive = False
        self.viewer.layers.selection.active = None
        
        # Initialize current angle and target angle
        self.current_angle = np.array(self.viewer.camera.angles)
        self.target_angle = np.array(target_angle)
        self.current_frame = 0  # Start from the first frame

        # Set up the timer to call rotate_camera function periodically (dynamic rotation)
        self.timer = QTimer()
        self.timer.setSingleShot(True)  # SingleShot ensures we control timer manually
        self.timer.timeout.connect(self.rotate_camera)

        # Set up the event loop
        self.loop = QEventLoop()

        # Start the first frame (timer will be restarted inside rotate_camera)
        self.timer.start(0)  # Start the first frame with a delay of 30 ms

        # Start the event loop, which will block until rotate_camera completes
        self.loop.exec_()

        self.timer = None
        self.viewer.camera.interactive = True
        self.viewer.layers.selection.active = self.points_layer

    def get_time(self):
        return self.viewer.dims.current_step[0]

    def remove_point(self, points_layer, pos=-1):

        self.prevent_update = True
        points_layer.data = points_layer.data[:pos]
        if "id" in points_layer.properties.keys():
            points_layer.properties["id"] = points_layer.properties["id"][:pos]
        self.prevent_update = False

        return

    def add_point(self, points_layer, point):

        self.prevent_update = True
        points_layer.data = np.vstack([points_layer.data, point])
        if "id" in points_layer.properties.keys():
            points_layer.properties["id"] = np.append(points_layer.properties["id"],[self.tracking_active_id])
        self.prevent_update = False

        return

    def add_point_properties(self, points_layer):

        if "id" in points_layer.properties.keys():
            if self.tracking_active:
                points_layer.properties["id"][-1] = self.tracking_active_id
            else:
                points_layer.properties["id"][-1] = np.nan

        return

    def jump_next(self):
        # Next step
        if self.jump_next_checkBox:
            current_time = self.get_time()
            if self.tracking_forward:
                self.viewer.dims.set_current_step(0, current_time + 1)
            else:
                self.viewer.dims.set_current_step(0, current_time - 1)

        return

    def update_points_layer_with_closest_point(self, closest_point):
        """
        Update the points layer: Remove the first two points and add the calculated closest point to the beginning.
        """
        # Check if there are at least two points in the layer before removing
        if len(self.points_layer.data) < 2:
            if self.debugging.isChecked():
                print("Not enough points in the layer to remove two points.")
            return

        # Remove the first two points (most recently added)
        self.remove_point(self.points_layer,pos=-2)
        # Add the calculated closest point to the beginning of the layer
        self.add_point(self.points_layer, closest_point)

        closest_point[0] += 1
        if closest_point[0] < self.length:
            self.add_point(self.points_layer_aux_forw, closest_point)
        closest_point[0] -= 2
        if closest_point[0] == 0:
            self.add_point(self.points_layer_aux_back, closest_point)

        if self.debugging.isChecked():
            print(f"First two points removed and closest point {closest_point} appended.")

    def question_tracking_direction(self):

        msg = QMessageBox()
        msg.setWindowTitle("Tracking movement")
        msg.setText("Do you want the tracking to move forwards or backwards?")
        msg.setIcon(QMessageBox.Question)

        # Add more than two buttons
        button_forward = msg.addButton("Forwards", QMessageBox.ActionRole)
        button_backward = msg.addButton("Backwards", QMessageBox.ActionRole)

        msg.exec_()

        if msg.clickedButton() == button_forward:
            self.tracking_forward = True
        elif msg.clickedButton() == button_backward:
            self.tracking_forward = False

    def new_tracking(self):
        """
        Create a new tracking id and activate the tracking.
        """

        self.viewer.layers.selection = [self.viewer.layers["Points Layer"]]
        # self.viewer.layers["Points Layer"].mode = 'add'

        if self.tracking_active:

                msg = QMessageBox()
                msg.setWindowTitle("Stop tracking")
                msg.setText("There is an already active tracking. Do you want to stop it and start a new tracking?")
                msg.setIcon(QMessageBox.Question)

                # Add more than two buttons
                button_yes = msg.addButton("Yes", QMessageBox.ActionRole)
                button_no = msg.addButton("No", QMessageBox.ActionRole)

                msg.exec_()

                if msg.clickedButton() == button_yes:
                    self.stop_tracking()
                elif msg.clickedButton() == button_no:
                    return

        if len(self.points_layer.selected_data) == 1:

            selected_pos = list(self.points_layer.selected_data)[0]
            selected_point = self.points_layer.data[selected_pos] 
            selected_time = selected_point[0]
            selected_id = self.points_layer.properties["id"][selected_pos]

            self.viewer.dims.current_step = (selected_time, *self.viewer.dims.current_step[1:])

            if np.isnan(selected_id):

                msg = QMessageBox()
                msg.setWindowTitle("Start from selected point")
                msg.setText("There is a point selected without id. Do you want to start a tracking from this point?")
                msg.setIcon(QMessageBox.Question)

                # Add more than two buttons
                button_yes = msg.addButton("Yes", QMessageBox.ActionRole)
                button_no = msg.addButton("No", QMessageBox.ActionRole)

                msg.exec_()

                if msg.clickedButton() == button_yes:

                    if selected_time == 0:

                        self.tracking_forward = True

                        msg = QMessageBox()
                        msg.setWindowTitle("Start from first point")
                        msg.setText("This is the first point, we are starting a forward tracking.")
                        msg.setIcon(QMessageBox.Question)

                        # Add more than two buttons
                        button_okay = msg.addButton("Okay", QMessageBox.ActionRole)

                        msg.exec_()

                    elif selected_time == self.length - 1:

                        self.tracking_forward = False

                        msg = QMessageBox()
                        msg.setWindowTitle("Start from last point")
                        msg.setText("This is the last point, we are starting a backward tracking.")
                        msg.setIcon(QMessageBox.Question)

                        # Add more than two buttons
                        button_okay = msg.addButton("Okay", QMessageBox.ActionRole)

                        msg.exec_()

                    else:

                        self.question_tracking_direction()

                    self.setup_active_tracking(id=None, tracking_time=selected_time)
                    self.update_tracks_layer_with_new_point(selected_point)
                    self.points_layer.properties["id"][selected_pos] = self.tracking_active_id
                    self.jump_next()

                    return

                elif msg.clickedButton() == button_no:

                    return

            keep = self.tracking_layer.data[:,0] == selected_id
            times = self.tracking_layer.data[keep,1]

            if np.any(times > selected_time):

                msg = QMessageBox()
                msg.setWindowTitle("Start from inner selected point")
                msg.setText(f"There is a point selected with tracking id {selected_id}. This point selected is in the middle of an existing track. Do you want it to set it as a division point and start a new track?")
                msg.setIcon(QMessageBox.Question)

                # Add more than two buttons
                button_yes = msg.addButton("Yes", QMessageBox.ActionRole)
                button_no = msg.addButton("No", QMessageBox.ActionRole)

                msg.exec_()

                if msg.clickedButton() == button_yes:

                    #Relabel future branch
                    self.tracking_forward = True
                    self.relabel_track(selected_point, selected_id)
                    self.setup_active_tracking()
                    self.update_tracks_layer_with_new_point(selected_point)
                    self.jump_next()

                elif msg.clickedButton() == button_no:

                    return

            else:

                msg = QMessageBox()
                msg.setWindowTitle("Start from end selected point")
                msg.setText(f"There is a point selected with tracking id {selected_id} that is the end of an existing track. Do you want to continue it?")
                msg.setIcon(QMessageBox.Question)

                # Add more than two buttons
                button_yes = msg.addButton("Yes", QMessageBox.ActionRole)
                button_no = msg.addButton("No", QMessageBox.ActionRole)

                msg.exec_()

                if msg.clickedButton() == button_yes:

                    #Relabel future branch
                    self.setup_active_tracking(id=selected_id, tracking_time=selected_time)
                    self.jump_next()

                elif msg.clickedButton() == button_no:

                    return

        elif len(self.points_layer.selected_data) > 1:

            msg = QMessageBox()
            msg.setWindowTitle("Several points")
            msg.setText(f"You cannot activate a tracking with several points selected.")
            msg.setIcon(QMessageBox.Question)

            msg.exec_()

        else:

            if self.get_time() == 0:

                msg = QMessageBox()
                msg.setWindowTitle("Initial trime point")
                msg.setText("You are in the first time point so you are starting a forward tracking.")
                msg.setIcon(QMessageBox.Warning)

                # Add more than two buttons
                button_yes = msg.addButton("Okay", QMessageBox.ActionRole)

                msg.exec_()

                self.tracking_forward = True
                self.setup_active_tracking()

            elif self.length > self.get_time()+1:

                self.question_tracking_direction()
                self.setup_active_tracking()

            else:

                msg = QMessageBox()
                msg.setWindowTitle("Last trime point")
                msg.setText("You are in the last time point so you are starting a backward tracking.")
                msg.setIcon(QMessageBox.Warning)

                # Add more than two buttons
                button_yes = msg.addButton("Okay", QMessageBox.ActionRole)

                msg.exec_()

                self.tracking_forward = False
                self.setup_active_tracking()

            return
    
    def relabel_track(self, selected_point, selected_id):

        selected_time = selected_point[0]
        self.tracking_max_id += 1
        keep_ids = self.tracking_layer.data[:,0] == selected_id
        keep_times = self.tracking_layer.data[:,1] > selected_time
        change = keep_ids*keep_times
        self.tracking_layer.data[change,0] = self.tracking_max_id
        keep_ids = self.points_layer.properties["id"] == selected_id
        keep_times = self.points_layer.data[:,1] > selected_time
        change = keep_ids*keep_times
        self.points_layer.properties["id"][change] = self.tracking_max_id
        self.update_tracks_layer_with_new_point(selected_point)

    def remove_track_point(self, selected_point, selected_id):

        selected_time = selected_point[0]

        # Relabel
        self.tracking_max_id += 1
        keep_ids = self.tracking_layer.data[:,0] == selected_id
        keep_times = self.tracking_layer.data[:,1] > selected_time
        change = keep_ids*keep_times
        self.tracking_layer.data[change,0] = self.tracking_max_id

        keep_ids = self.points_layer.properties["id"] == selected_id
        keep_times = self.points_layer.data[:,1] > selected_time
        change = keep_ids*keep_times
        self.points_layer.properties["id"][change] = self.tracking_max_id

        # Remove point
        self.prevent_update = True

        keep_ids = self.tracking_layer.data[:,0] == selected_id
        keep_times = self.tracking_layer.data[:,1] == selected_time
        change = ~(keep_ids*keep_times)
        self.tracking_layer.data = self.tracking_layer.data[change,:]

        keep_ids = self.points_layer.properties["id"] == self.tracking_max_id
        keep_times = self.points_layer.data[:,0] == selected_time
        change = ~(keep_ids*keep_times)
        self.points_layer.data = self.points_layer.data[change,:]

        self.prevent_update = False

    def remove_track(self, selected_point, selected_id):

        # Remove points
        self.prevent_update = True

        keep_ids = ~(self.tracking_layer.data[:,0] == selected_id)
        self.tracking_layer.data = self.tracking_layer.data[keep_ids,:]

        keep_ids = ~(self.points_layer.properties["id"] == selected_id)
        self.points_layer.data = self.points_layer.data[keep_ids,:]

        self.prevent_update = False

    def setup_active_tracking(self, id=None, tracking_time=None):

        if id == None:
            self.tracking_max_id += 1
            self.tracking_active_id = self.tracking_max_id
        else:
            self.tracking_active_id = id

        self.tracking_active = True

        if tracking_time == None:
            if self.tracking_forward:
                self.tracking_time = self.get_time()-1
            else:
                self.tracking_time = self.get_time()+1
        else:
            self.tracking_time = tracking_time

        if self.tracking_forward:
            self.viewer.layers["Auxiliar Backward Tracking Points"].visible = False
            self.viewer.layers["Auxiliar Backward Image Layer"].visible = False
            self.viewer.layers["Auxiliar Forward Tracking Points"].visible = True
            self.viewer.layers["Auxiliar Forward Image Layer"].visible = True
        else:
            self.viewer.layers["Auxiliar Backward Tracking Points"].visible = True
            self.viewer.layers["Auxiliar Backward Image Layer"].visible = True
            self.viewer.layers["Auxiliar Forward Tracking Points"].visible = False
            self.viewer.layers["Auxiliar Forward Image Layer"].visible = False

        self.start_tracking_button.setStyleSheet(
                    "QPushButton {"
                        "background-color: green;"  # Green background
                    "}"
                )
        
        return

    def stop_tracking(self):
        """
        Stop tracking.
        """

        self.tracking_active = False
        self.tracking_active_id = np.nan

        self.start_tracking_button.setStyleSheet("")

        self.points_layer.selected_data = []
        self.point1_angle = None
        self.point2_angle = None

        return

    def update_tracks_layer_with_new_point(self, point):
        """
        Update the tracking layer.
        """
        if self.tracking_active:
            track_point = np.append([self.tracking_active_id], point)
            self.tracking_layer.data = np.vstack([self.tracking_layer.data, track_point])

            if self.length <= self.get_time()+1 and self.tracking_forward:

                self.stop_tracking()

                msg = QMessageBox()
                msg.setWindowTitle("Final time point reached")
                msg.setText("You are in the last time point when tracking forward. The track has stopped.")
                msg.setIcon(QMessageBox.Warning)

                # Add more than two buttons
                button_yes = msg.addButton("Okay", QMessageBox.ActionRole)

                msg.exec_()

            elif 0 > self.get_time()-1 and not self.tracking_forward:

                self.stop_tracking()

                msg = QMessageBox()
                msg.setWindowTitle("Initial time point reached")
                msg.setText("You are in the first time point when tracking backwards. The track has stopped.")
                msg.setIcon(QMessageBox.Warning)

                # Add more than two buttons
                button_yes = msg.addButton("Okay", QMessageBox.ActionRole)

                msg.exec_()

            self.tracking_time = self.get_time()

        return

    # def make_vector_layer(self):
    #     """Update the combo box with existing points layers."""
    #     if "Debug" in self.viewer.layers:
    #         if isinstance(self.viewer.layers["Debug"], napari.layers.Vectors):
    #             del self.viewer.layers["Debug"]

    #     # Add all existing Points layers to the combo box
    #     self.vectors_layer = self.viewer.add_vectors(
    #         np.zeros([0,2,3]), 
    #         name='Debug_Vectors', 
    #         length=100,
    #         edge_width=2, 
    #         edge_color='green',
    #         # scale=self.image_layer.scale[1:]
    #         )

    # def update_vectors_layer(self):
    #     """Update or create a vectors layer to visualize the directions from the points."""
    #     # Define the vector data format: [start_point, vector]
    #     scale = np.array(self.image_layer.scale[1:])
    #     vectors_data = np.array([
    #         [self.point1[1:], self.direction1],
    #         [self.point2[1:], self.direction2]
    #     ])
        
    #     self.vectors_layer.data = vectors_data
    #     print("Vectors layer updated.")

    def compute_camera_direction(self):
        """
        Compute the camera direction using the Euler angles and center of the camera.
        Napari gives the camera's Euler angles in degrees and the center of rotation.
        """

        # Calculate the view direction based on the camera's current angles
        view_direction = self.viewer.camera.calculate_nd_view_direction(3, (0,1,2))

        return view_direction

    def calculate_closest_point(self, point1, d1, point2, d2):
        """
        Finds the closest points on two skew (non-intersecting) lines in 3D.
        
        Parameters:
        P1 : np.array
            A point on line 1 (3D vector).
        d1 : np.array
            The direction vector of line 1 (3D vector).
        P2 : np.array
            A point on line 2 (3D vector).
        d2 : np.array
            The direction vector of line 2 (3D vector).
            
        Returns:
        Q1 : np.array
            Closest point on line 1 to line 2 (3D vector).
        Q2 : np.array
            Closest point on line 2 to line 1 (3D vector).
        distance : float
            The shortest distance between the two lines.
        """
        
        time = point1[0]
        P1 = point1[1:]
        P2 = point2[1:]

        # Convert input points and direction vectors to numpy arrays
        scale = np.array(self.image_layer.scale[1:])
        P1 = np.array(P1)*scale
        d1 = np.array(d1)
        P2 = np.array(P2)*scale
        d2 = np.array(d2)
        
        # Vector between the two points
        P12 = P2 - P1
        
        # Cross product of the direction vectors
        n = np.cross(d1, d2)
        
        # # If the cross product is zero, the lines are parallel
        # if np.allclose(n, 0):
        #     raise ValueError("The lines are parallel and do not have a unique closest pair of points.")
        
        # Coefficients for the system of equations
        d1_dot_d1 = np.dot(d1, d1)
        d2_dot_d2 = np.dot(d2, d2)
        d1_dot_d2 = np.dot(d1, d2)
        P12_dot_d1 = np.dot(P12, d1)
        P12_dot_d2 = np.dot(P12, d2)
        
        # Solving for t1 and t2 using Cramer's rule
        denominator = d1_dot_d1 * d2_dot_d2 - d1_dot_d2**2
        t1 = (P12_dot_d1 * d2_dot_d2 - P12_dot_d2 * d1_dot_d2) / denominator
        t2 = (P12_dot_d1 * d1_dot_d2 - P12_dot_d2 * d1_dot_d1) / denominator
        
        # Find the closest points on each line
        Q1 = P1 + t1 * d1  # Closest point on line 1
        Q2 = P2 + t2 * d2  # Closest point on line 2
        
        # Compute the shortest distance between the two lines
        distance = np.linalg.norm(Q1 - Q2)
        
        pos = ( Q1 + Q2 ) /2 / scale

        closest_point = np.append([time],pos)

        return closest_point

    def save(self):

        # Create empty points.npy (for storing points layers later)
        np.save(f"{self.points_layer.metadata['path']}/points.npy", self.points_layer.data)

        # Create empty points.npy (for storing points layers later)
        np.save(f"{self.points_layer.metadata['path']}/points_id.npy", self.points_layer.properties["id"])

        # Create empty trackings.npy (for storing tracking layers later)
        np.save(f"{self.tracking_layer.metadata['path']}/trackings.npy", self.tracking_layer.data)

# Napari plugin function
def napari_experimental_provide_dock_widget():
    return SetUpTracking, LoadTracking, ManualTracking, Parabola
