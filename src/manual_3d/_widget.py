"""
This module contains four napari widgets declared in
different ways:

- a pure Python function flagged with `autogenerate: true`
    in the plugin manifest. Type annotations are used by
    magicgui to generate widgets for each parameter. Best
    suited for simple processing tasks - usually taking
    in and/or returning a layer.
- a `magic_factory` decorated function. The `magic_factory`
    decorator allows us to customize aspects of the resulting
    GUI, including the widgets associated with each parameter.
    Best used when you have a very simple processing task,
    but want some control over the autogenerated widgets. If you
    find yourself needing to define lots of nested functions to achieve
    your functionality, maybe look at the `Container` widget!
- a `magicgui.widgets.Container` subclass. This provides lots
    of flexibility and customization options while still supporting
    `magicgui` widgets and convenience methods for creating widgets
    from type annotations. If you want to customize your widgets and
    connect callbacks, this is the best widget option for you.
- a `QWidget` subclass. This provides maximal flexibility but requires
    full specification of widget layouts, callbacks, events, etc.

References:
- Widget specification: https://napari.org/stable/plugins/guides.html?#widgets
- magicgui docs: https://pyapp-kit.github.io/magicgui/

Replace code below according to your needs.
"""
from typing import TYPE_CHECKING

from magicgui import magic_factory
from magicgui.widgets import CheckBox, Container, create_widget
from qtpy.QtWidgets import QHBoxLayout, QPushButton, QWidget
from skimage.util import img_as_float
import numpy as np

if TYPE_CHECKING:
    import napari


# Uses the `autogenerate: true` flag in the plugin manifest
# to indicate it should be wrapped as a magicgui to autogenerate
# a widget.
def set_voxel(
    img: "napari.types.ImageData",
    threshold: "float",
) -> "napari.types.ImageData":
    return img_as_float(img) > threshold


# def activate_widget(
#     img: "napari.types.PointsData",
#     threshold: "float",
# ) -> None:
#     print("Hi")
#     return


# # the magic_factory decorator lets us customize aspects of our widget
# # we specify a widget type for the threshold parameter
# # and use auto_call=True so the function is called whenever
# # the value of a parameter changes
# @magic_factory(
#     threshold={"widget_type": "FloatSlider", "max": 1}, auto_call=True
# )
# def threshold_magic_widget(
#     img_layer: "napari.layers.Image", threshold: "float"
# ) -> "napari.types.LabelsData":
#     return img_as_float(img_layer.data) > threshold

# the magic_factory decorator lets us customize aspects of our widget
# we specify a widget type for the threshold parameter
# and use auto_call=True so the function is called whenever
# the value of a parameter changes
@magic_factory(
    voxel_x={"widget_type": "FloatSlider", "max": 10},
    voxel_y={"widget_type": "FloatSlider", "max": 10},
    voxel_z={"widget_type": "FloatSlider", "max": 10}, 
    call_button="Set Voxel Size",
    auto_call=False
)
def change_voxel_size(
    img_layer: "napari.layers.Image", 
    voxel_x: "float",
    voxel_y: "float",
    voxel_z: "float",
    viewer: "napari.viewer.Viewer", 
) -> None:#-> "napari.types.image":
    voxel = (voxel_z,voxel_y,voxel_x)
    shape = img_layer.data.shape
    if np.any(np.array(voxel)>0):
        #Set scale
        img_layer.scale = voxel
        #Reset camera center
        viewer.camera.center = tuple(np.array(voxel)*shape/2)
    return

# if we want even more control over our widget, we can use
# magicgui `Container`
    
from napari.utils.events import Event
from napari import Viewer
from qtpy.QtWidgets import QApplication, QWidget

# class FindPeaks(Container):
#     def __init__(self, viewer: "napari.viewer.Viewer"):
        
#         super().__init__()
#         self._viewer = viewer
#         # use create_widget to generate widgets from type annotations
#         self._image_layer = create_widget(
#             label="Image", annotation="napari.layers.Image"
#         )
#         self._points_layer = create_widget(
#             label="Points", annotation="napari.layers.Points"
#         )
#         self._gaussian_filter_slider = create_widget(
#             label="Gaussian", annotation=float, widget_type="FloatSlider"
#         )
#         self._gaussian_filter_slider.min = 0
#         self._gaussian_filter_slider.max = 100
#         # use magicgui widgets directly
#         # self._invert_checkbox = CheckBox(text="Keep pixels below threshold")

#         # connect your own callbacks
#         self._gaussian_filter_slider.changed.connect(self._threshold_im)
#         # self._invert_checkbox.changed.connect(self._threshold_im)
#         self._compute = create_widget(
#             label="Compute", annotation=float, widget_type="PushButton"
#         )

#         # append into/extend the container with your widgets
#         self.extend(
#             [
#                 self._image_layer,
#                 self._points_layer,
#                 self._gaussian_filter_slider,
#                 # self._invert_checkbox,
#                 self._compute,
#             ]
#         )

#         self._viewer.layers.events.inserting.connect(self.my_callback)

#     def my_callback(event: Event):
#         print("The number of dims shown is now:", event)        

#     def _threshold_im(self):
#         image_layer = self._image_layer_combo.value
#         if image_layer is None:
#             return

#         image = img_as_float(image_layer.data)
#         name = image_layer.name + "_thresholded"
#         threshold = self._gaussian_filter_slider.value
#         if self._invert_checkbox.value:
#             thresholded = image < threshold
#         else:
#             thresholded = image > threshold
#         if name in self._viewer.layers:
#             self._viewer.layers[name].data = thresholded
#         else:
#             self._viewer.add_labels(thresholded, name=name)


# class ExampleQWidget(QWidget):

import napari
from qtpy.QtWidgets import QWidget, QVBoxLayout, QLabel, QComboBox
from qtpy.QtCore import Qt


class FindPeaks(QWidget):
    def __init__(self, napari_viewer):
        super().__init__()

        self.viewer = napari_viewer
        self.points_layer = None  # This will store the linked points layer

        # Set up the UI
        self.setWindowTitle("FindPeaks")
        self.setGeometry(100, 100, 300, 200)

        # Layout
        layout = QVBoxLayout()

        # Label
        self.label = QLabel("Select a Points layer:")
        layout.addWidget(self.label)

        # Combo box to select existing points layer
        self.layer_selector = QComboBox()
        self.update_layer_list()  # Fill the combo box with existing layers
        layout.addWidget(self.layer_selector)

        # Connect the dropdown to automatically link when a selection is made
        self.layer_selector.currentIndexChanged.connect(self.link_to_points_layer)

        # Connect to the Napari viewer's layer insertion event
        self.viewer.layers.events.inserted.connect(self.on_layer_inserted)

        self.setLayout(layout)

    def update_layer_list(self):
        """Update the combo box with existing points layers."""
        self.layer_selector.clear()

        # Add all existing Points layers to the combo box
        for layer in self.viewer.layers:
            if isinstance(layer, napari.layers.Points):
                self.layer_selector.addItem(layer.name)

    def on_layer_inserted(self, event):
        """Triggered when a new layer is added to the viewer."""
        new_layer = event.value
        if isinstance(new_layer, napari.layers.Points):
            self.layer_selector.addItem(new_layer.name)
            print(f"New Points layer '{new_layer.name}' added to the combo box.")

    def link_to_points_layer(self):
        """Link the widget to the selected points layer."""
        selected_item = self.layer_selector.currentText()

        if selected_item:
            # Link to the selected existing points layer
            self.points_layer = self.viewer.layers[selected_item]
            print(f"Linked to existing points layer: {selected_item}")
        else:
            print("No Points layer selected.")

    def showEvent(self, event):
        """Triggered when the widget is shown, connects the mouse click event."""
        self.viewer.mouse_drag_callbacks.append(self.mouse_click_callback)
        self.update_layer_list()  # Update the list of layers whenever the widget is shown
        print("Mouse click callback linked.")
        super().showEvent(event)

    def hideEvent(self, event):
        """Triggered when the widget is hidden, disconnects the mouse click event."""
        if self.mouse_click_callback in self.viewer.mouse_drag_callbacks:
            self.viewer.mouse_drag_callbacks.remove(self.mouse_click_callback)
        print("Mouse click callback unlinked.")
        super().hideEvent(event)

    def mouse_click_callback(self, viewer, event):
        """Callback function to store the mouse position when clicked and add it to the points layer."""
        # Check if we are in 2D or 3D mode
        if self.viewer.dims.ndisplay == 2:
            position = event.position  # 2D world coordinates
            print(f"Mouse clicked at (2D): {position}")
        else:
            # 3D world coordinates
            # Need to convert the click to world coordinates in 3D
            position = event.position  # Already in 3D world coordinates
            print(f"Mouse clicked at (3D): {position}")

        # Add the position to the linked points layer if one is selected
        if self.points_layer is not None:
            self.points_layer.add([position])
            print(f"Added point at: {position} to the points layer.")

    def on_hide(self):
        print("Widget was hidden")

    def on_show(self):
        print("Widget was shown")


# Napari plugin function
def napari_experimental_provide_dock_widget():
    return FindPeaks
