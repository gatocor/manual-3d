"""
This module contains four napari widgets declared in
different ways:

- a pure Python function flagged with `autogenerate: true`
    in the plugin manifest. Type annotations are used by
    magicgui to generate widgets for each parameter. Best
    suited for simple processing tasks - usually taking
    in and/or returning a layer.
- a `magic_factory` decorated function. The `magic_factory`
    decorator allows us to customize aspects of the resulting
    GUI, including the widgets associated with each parameter.
    Best used when you have a very simple processing task,
    but want some control over the autogenerated widgets. If you
    find yourself needing to define lots of nested functions to achieve
    your functionality, maybe look at the `Container` widget!
- a `magicgui.widgets.Container` subclass. This provides lots
    of flexibility and customization options while still supporting
    `magicgui` widgets and convenience methods for creating widgets
    from type annotations. If you want to customize your widgets and
    connect callbacks, this is the best widget option for you.
- a `QWidget` subclass. This provides maximal flexibility but requires
    full specification of widget layouts, callbacks, events, etc.

References:
- Widget specification: https://napari.org/stable/plugins/guides.html?#widgets
- magicgui docs: https://pyapp-kit.github.io/magicgui/

Replace code below according to your needs.
"""
from typing import TYPE_CHECKING

from magicgui import magic_factory
from magicgui.widgets import CheckBox, Container, create_widget
from qtpy.QtWidgets import (
    QWidget, QVBoxLayout, QLabel, QCheckBox, QPushButton, QLineEdit, QFileDialog, QDoubleSpinBox, QSpinBox, QMessageBox, QApplication, QWidget
)
from qtpy.QtCore import Qt
import os
from skimage.util import img_as_float
import numpy as np
from magicgui.widgets import FileEdit
from .utils import *
from scipy.ndimage import gaussian_filter
from skimage.feature import peak_local_max
import napari
import re
import json
import inspect

if TYPE_CHECKING:
    import napari

class SetUpTracking(QWidget):
    def __init__(self, napari_viewer):
        super().__init__()

        # Add viewer
        self.viewer = napari_viewer

        # Create the layout
        self.layout = QVBoxLayout()

        # Path input
        self.path_label = QLabel("Path to Data Folder:")
        self.path_input = QLineEdit(self)
        self.browse_button = QPushButton("Browse Folder")
        self.browse_button.clicked.connect(self.browse_folder)
        self.layout.addWidget(self.path_label)
        self.layout.addWidget(self.path_input)
        self.layout.addWidget(self.browse_button)

        # Start and end points
        self.start_label = QLabel("Start Point:")
        self.start_input = QSpinBox(self)
        self.start_input.setMinimum(0)
        self.start_input.setMaximum(999999)
        self.end_label = QLabel("End Point:")
        self.end_input = QSpinBox(self)
        self.end_input.setMinimum(0)
        self.end_input.setMaximum(999999)
        self.layout.addWidget(self.start_label)
        self.layout.addWidget(self.start_input)
        self.layout.addWidget(self.end_label)
        self.layout.addWidget(self.end_input)

        # Format input
        self.format_label = QLabel("Format:")
        self.format_input = QLineEdit(self)
        self.layout.addWidget(self.format_label)
        self.layout.addWidget(self.format_input)

        # Voxel sizes
        self.voxel_x_label = QLabel("Voxel X:")
        self.voxel_x_input = QDoubleSpinBox(self)
        self.voxel_x_input.setDecimals(3)
        self.voxel_x_input.setValue(0.347)
        self.voxel_x_input.setSingleStep(0.001)
        self.voxel_y_label = QLabel("Voxel Y:")
        self.voxel_y_input = QDoubleSpinBox(self)
        self.voxel_y_input.setDecimals(3)
        self.voxel_y_input.setValue(0.347)
        self.voxel_y_input.setSingleStep(0.001)
        self.voxel_z_label = QLabel("Voxel Z:")
        self.voxel_z_input = QDoubleSpinBox(self)
        self.voxel_z_input.setDecimals(3)
        self.voxel_z_input.setValue(2.0)
        self.voxel_z_input.setSingleStep(0.001)
        self.layout.addWidget(self.voxel_x_label)
        self.layout.addWidget(self.voxel_x_input)
        self.layout.addWidget(self.voxel_y_label)
        self.layout.addWidget(self.voxel_y_input)
        self.layout.addWidget(self.voxel_z_label)
        self.layout.addWidget(self.voxel_z_input)

        # Folder input for storing the JSON file
        self.folder_label = QLabel("Path to where to save project:")
        self.folder_input = QLineEdit(self)
        self.browse_folder_button = QPushButton("Browse Folder")
        self.browse_folder_button.clicked.connect(self.browse_json_folder)
        self.layout.addWidget(self.folder_label)
        self.layout.addWidget(self.folder_input)
        self.layout.addWidget(self.browse_folder_button)

        # Save button
        self.save_button = QPushButton("Create tracking project")
        self.save_button.clicked.connect(self.save_to_json)
        self.layout.addWidget(self.save_button)

        # Set the layout
        self.setLayout(self.layout)

        # Internal variable to store the number of files
        self.file_count = 0

    def browse_folder(self):
        """Open a file dialog to browse for a folder and count the number of files."""
        folder_path = QFileDialog.getExistingDirectory(self, "Select Data Folder")
        if folder_path:
            self.path_input.setText(folder_path)
            self.count_files_in_folder(folder_path)
            self.detect_file_pattern(folder_path)

    def browse_json_folder(self):
        """Open a file dialog to select a folder to save JSON."""
        folder_path = QFileDialog.getExistingDirectory(self, "Select Project")
        if folder_path:
            self.folder_input.setText(folder_path)

    def count_files_in_folder(self, folder_path):
        """Count the number of files in the selected folder and set the start and end points."""
        try:
            file_list = os.listdir(folder_path)
            self.file_count = len(file_list)
        except Exception as e:
            print(f"Error counting files: {e}")

    def detect_file_pattern(self, folder_path):
        """Detect the file naming pattern, start and end points, and suggest it as the format."""
        try:
            file_list = os.listdir(folder_path)
            file_list = [f for f in file_list if os.path.isfile(os.path.join(folder_path, f))]
            file_list.sort()  # Ensure the files are sorted correctly

            if len(file_list) < 2:
                return  # We need at least two files to detect a pattern

            # Compare first and final filenames to identify the changing numeric pattern
            file_1, file_2 = file_list[0], file_list[-1]
            format_str = []
            num_pattern = re.compile(r'\d+')  # Pattern to match numbers
            numeric_values = []

            i = 0
            while i < len(file_1):
                if i < len(file_2) and file_1[i] == file_2[i]:
                    format_str.append(file_1[i])  # If characters are the same, add them to format
                elif num_pattern.match(file_1[i:]):
                    # Detect numeric sequence, determine its length
                    num_match_1 = num_pattern.match(file_1[i:])
                    num_match_2 = num_pattern.match(file_2[i:])
                    
                    if num_match_1 and num_match_2:
                        length_1 = len(num_match_1.group(0))
                        length_2 = len(num_match_2.group(0))
                        if length_1 == length_2:  # Only replace if the lengths of numbers are the same
                            format_str.append(f"{{:0{length_1}d}}")  # Use the correct number of digits
                            # Collect the numeric values from all files to detect min/max
                            for file_name in file_list:
                                match = num_pattern.search(file_name)
                                if match:
                                    numeric_values.append(int(match.group(0)))
                            i += length_1 - 1  # Skip past the numeric part
                        else:
                            format_str.append(file_1[i])
                    else:
                        format_str.append(file_1[i])
                else:
                    format_str.append(file_1[i])
                i += 1

            # Join format string and update the format input
            detected_format = ''.join(format_str)
            self.format_input.setText(detected_format)

            # Set start and end points based on the detected numeric sequence
            if numeric_values:
                self.start_input.setValue(min(numeric_values))
                self.end_input.setValue(max(numeric_values))

        except Exception as e:
            print(f"Error detecting file pattern: {e}")


    def save_to_json(self):
        """Save the current input to a JSON file in the selected folder and create NumPy files for points and tracking layers."""
        settings = {
            'path_data': self.path_input.text(),
            'start_point': self.start_input.value(),
            'end_point': self.end_input.value(),
            'format_str': self.format_input.text(),
            'voxel_x': self.voxel_x_input.value(),
            'voxel_y': self.voxel_y_input.value(),
            'voxel_z': self.voxel_z_input.value(),
        }
        
        folder_path = self.folder_input.text()
        if folder_path:
            # Check if folder is empty
            if os.listdir(folder_path):  # Folder is not empty
                reply = QMessageBox.question(
                    self, 
                    'Folder Not Empty', 
                    "The selected folder is not empty. Do you want to overwrite the contents?",
                    QMessageBox.Yes | QMessageBox.No, 
                    QMessageBox.No
                )

                if reply == QMessageBox.No:
                    return  # Do not proceed with saving
                # If user clicks "Yes", proceed with the saving process

            # Define file paths
            settings_file_path = os.path.join(folder_path, 'settings.json')
            points_file_path = os.path.join(folder_path, 'points.npy')
            points_id_file_path = os.path.join(folder_path, 'points_id.npy')
            trackings_file_path = os.path.join(folder_path, 'trackings.npy')
            
            try:
                # Save settings.json
                with open(settings_file_path, 'w') as settings_file:
                    json.dump(settings, settings_file, indent=4)

                # Create empty points.npy (for storing points layers later)
                points_array = np.empty((0, 4))  # Assuming points are in 3D, create an empty array
                np.save(points_file_path, points_array)

                # Create empty points.npy (for storing points layers later)
                points_id_array = np.empty((0))  # Assuming points are in 3D, create an empty array
                np.save(points_id_file_path, points_id_array)

                # Create empty trackings.npy (for storing tracking layers later)
                trackings_array = np.empty((0, 5))  # Assuming trackings are in 3D, create an empty array
                np.save(trackings_file_path, trackings_array)

                print(f"Settings saved to {settings_file_path}")
                print(f"Empty points.npy and trackings.npy created in {folder_path}")
            except Exception as e:
                print(f"Error saving files: {e}")
        else:
            print("No folder selected for saving.")

class LoadTracking(QWidget):
    def __init__(self, napari_viewer):
        super().__init__()

        # Add napari viewer
        self.viewer = napari_viewer

        # Create the layout
        self.layout = QVBoxLayout()

        # Folder selection input
        self.folder_label = QLabel("Select Project Folder:")
        self.folder_input = QLineEdit(self)
        self.browse_folder_button = QPushButton("Browse Folder")
        self.browse_folder_button.clicked.connect(self.browse_folder)
        self.layout.addWidget(self.folder_label)
        self.layout.addWidget(self.folder_input)
        self.layout.addWidget(self.browse_folder_button)

        # Layer checkboxes (default all checked)
        self.data_checkbox = QCheckBox("Data")
        self.data_checkbox.setChecked(True)
        self.layout.addWidget(self.data_checkbox)

        self.points_checkbox = QCheckBox("Points")
        self.points_checkbox.setChecked(True)
        self.layout.addWidget(self.points_checkbox)

        self.tracking_checkbox = QCheckBox("Tracking")
        self.tracking_checkbox.setChecked(True)
        self.layout.addWidget(self.tracking_checkbox)

        # Load button
        self.load_button = QPushButton("Load Layers")
        self.load_button.clicked.connect(self.load_layers)
        self.layout.addWidget(self.load_button)

        # Set the layout
        self.setLayout(self.layout)

    def browse_folder(self):
        """Open a file dialog to browse for the project folder."""
        folder_path = QFileDialog.getExistingDirectory(self, "Select Project Folder")
        if folder_path:
            self.folder_input.setText(folder_path)

    def load_layers(self):
        """Load the selected layers based on user input."""
        folder_path = self.folder_input.text()

        # Ensure the folder path is valid
        if not os.path.exists(folder_path):
            print("Invalid folder path.")
            return

        # Load settings from settings.json
        settings_file = os.path.join(folder_path, "settings.json")
        if not os.path.exists(settings_file):
            print("settings.json not found.")
            return

        try:
            with open(settings_file, 'r') as f:
                settings = json.load(f)
        except Exception as e:
            print(f"Error loading settings.json: {e}")
            return

        voxel_x = settings.get('voxel_x', 1.0)
        voxel_y = settings.get('voxel_y', 1.0)
        voxel_z = settings.get('voxel_z', 1.0)
        scale = [voxel_z, voxel_y, voxel_x]

        # Load the selected layers
        if self.data_checkbox.isChecked():
            self.load_data_layer(folder_path, settings, scale)

        if self.points_checkbox.isChecked():
            self.load_points_layer(folder_path, scale)

        if self.tracking_checkbox.isChecked():
            self.load_tracking_layer(folder_path, scale)

    def load_data_layer(self, folder_path, settings, scale):
        """Load the data layer from the project folder."""
        try:
            # Assuming read_split_times is defined elsewhere
            path_data = settings['path_data']
            start_point = settings['start_point']
            end_point = settings['end_point']
            format_str = settings['format_str']
            
            # Load the movie/data layer
            image = read_split_times(
                str(path_data),
                range(start_point, end_point + 1),
                format_str
            )[0][:, :, 0, :, :]
            
            # Add the image layer to the viewer
            self.viewer.add_image(image, scale=scale, name="Data Layer")
            print("Data layer loaded successfully.")
        except Exception as e:
            print(f"Error loading data layer: {e}")

    def load_points_layer(self, folder_path, scale):
        """Load the points layer from points.npy, even if it's empty."""
        points_file = os.path.join(folder_path, "points.npy")
        points = np.empty((0, 4))  # Default empty points array in 3D

        points_id_file = os.path.join(folder_path, "points_id.npy")
        points_id = np.empty((0))  # Default empty points array in 3D

        if os.path.exists(points_file):
            try:
                points = np.load(points_file)
                points_id = np.load(points_id_file)
            except Exception as e:
                print(f"Error loading points layer: {e}")

        # Add points layer to Napari viewer (even if empty)
        self.viewer.add_points(points, properties={'id':points_id}, scale=np.append([1],scale), name="Points Layer")
        print("Points layer (empty or not) loaded successfully.")

    def load_tracking_layer(self, folder_path, scale):
        """Load the tracking layer from trackings.npy, even if it's empty."""
        tracking_file = os.path.join(folder_path, "trackings.npy")

        if os.path.exists(tracking_file):
            try:
                trackings = np.load(tracking_file)
            except Exception as e:
                print(f"Error loading tracking layer: {e}")

        if len(trackings) == 0:
            trackings = np.zeros((1, 5))  # Default empty tracks array

        # Add tracks layer to Napari viewer (even if empty)
        # self.viewer.add_tracks(trackings, scale=np.append([1,1],scale), name="Tracking Layer")
        self.viewer.add_tracks(trackings, name="Tracking Layer", scale=np.append([1],scale))
        print("Tracking layer (empty or not) loaded successfully.")

class ManualTracking(QWidget):
    def __init__(self, napari_viewer):
        super().__init__()

        # Add napari viewer
        self.viewer = napari_viewer

        # Create the layout
        self.layout = QVBoxLayout()

        # Add checkbox for manual tracking activation/deactivation
        self.click_3D = QCheckBox("3D clicking")
        self.click_3D.setChecked(True)
        self.layout.addWidget(self.click_3D)

        # Set the layout
        self.setLayout(self.layout)

        # Store references to new layers added (for easy removal)
        self.image_layer = self.viewer.layers['Data Layer']
        self.points_layer = self.viewer.layers['Points Layer']
        self.tracking_layer = self.viewer.layers['Tracking Layer']
        self.length = len(self.image_layer.data)
        self.points_layer.events.data.connect(self.on_point_added)

        # Auxiliar connect
        self.image_layer_aux = None
        self.points_layer_aux = None
        self.process_image_layer_aux()
        self.process_points_layer_aux()

        # To store the two points and directions
        self.point1 = None
        self.direction1 = None
        self.point2 = None
        self.direction2 = None
        self.counter = 0

        self.prevent_update = False

        #Track
        self.tracking_active = False
        self.tracking_active_id = 0
        self.tracking_time = 0
        if np.all(self.tracking_layer.data == 0):
            self.tracking_max_id = 0
        else:
            self.tracking_max_id = np.max(self.viewer.layers['Tracking Layer'].data,axis=0)[0]
        self.start_tracking_button = QPushButton("Start Tracking")
        self.layout.addWidget(self.start_tracking_button)
        self.start_tracking_button.clicked.connect(self.new_tracking)
        self.stop_tracking_button = QPushButton("Stop Tracking")
        self.layout.addWidget(self.stop_tracking_button)
        self.stop_tracking_button.clicked.connect(self.stop_tracking)

        # Jump Next
        self.jump_next_checkBox = QCheckBox("Jump automatically to next image.")
        self.jump_next_checkBox.setChecked(True)
        self.layout.addWidget(self.jump_next_checkBox)

        # Debug
        self.debugging = QCheckBox("Debugging")
        self.debugging.setChecked(False)
        self.layout.addWidget(self.debugging)

        self.viewer.layers.selection.active = self.viewer.layers['Points Layer']

        # #Debug
        # self.vectorcheckbox = QCheckBox("Debug")
        # self.layout.addWidget(self.vectorcheckbox)
        # self.vectorcheckbox.stateChanged.connect(self.make_vector_layer)

    def hideEvent(self, event):
        """Triggered when the widget is hidden, disconnect the point added callback if active."""
        if self.points_layer is not None:
            self.points_layer.events.data.disconnect(self.on_point_added)
        if self.image_layer_aux is not None:
            self.viewer.layers.remove(self.image_layer_aux)
        if self.points_layer_aux is not None:
            self.viewer.layers.remove(self.points_layer_aux)
        super().hideEvent(event)

    def process_image_layer_aux(self):
        """Process the image layer by adding an initial time of zeros and removing the last image, using a memory-efficient view."""
        # Check if 'Data Layer' exists in the viewer
        if 'Data Layer' in self.viewer.layers:
            original_image = self.viewer.layers['Data Layer'].data
            original_scale = self.viewer.layers['Data Layer'].scale  # Get original scale

            # Create a memory-efficient view by skipping the last frame of the original image
            view_image = original_image[:-1]  # This is a view, not a copy

            # Add an additional frame of zeros at the beginning without copying the entire array
            zero_frame = np.zeros_like(view_image[0:1])  # Just one frame of zeros
            new_image = np.concatenate((zero_frame, view_image), axis=0)  # Combine with view

            # Add the new image layer with green color code, keeping the original scale
            self.image_layer_aux = self.viewer.add_image(new_image, colormap='green', name="Manual Tracking Data Layer", opacity=0.5, scale=original_scale)
        else:
            print("Data Layer not found in the viewer.")

    def process_points_layer_aux(self):
        """Process points layer by shifting time backward and applying green color and cross shape, using a memory-efficient view."""
        # Check if 'Points Layer' exists in the viewer
        if 'Points Layer' in self.viewer.layers:
            original_points = self.viewer.layers['Points Layer'].data
            original_scale = self.viewer.layers['Points Layer'].scale  # Get original scale

            # Create a view of the original points data and shift the time points backward
            modified_points = original_points.copy()
            modified_points[:, 0] += 1  # Assuming time is the first column
            modified_points = modified_points[modified_points[:,0]<self.length]

            # Add the new points layer with green cross markers, keeping the original scale
            self.points_layer_aux = self.viewer.add_points(modified_points, size=8, face_color='green', symbol='cross', name="Manual Tracking Points", scale=original_scale)
        else:
            print("Points Layer not found in the viewer.")

    def on_point_added(self, event):
        """Callback triggered when a new point is added to the points layer."""

        if self.counter == 0:
            self.counter = 1
            return
        else:
            self.counter = 0

        if self.prevent_update:
            return

        if not self.click_3D.isChecked():
            return
        
        if 0 in self.viewer.dims.displayed:
            if self.debugging.isChecked():
                print("Not in (XYZ) perspective. Ignoring point addition.")
            self.removePoint(self.points_layer)
            return

        if self.tracking_active:
            if self.tracking_time+1 != self.get_time():    
                reply = QMessageBox.question(
                    self, 
                    'Trajectory causality broken', 
                    f"You are tracking and the time you are adding a point is not the immediate next point of the current tracking (last was {self.tracking_time}, current {self.get_time()}). Maybe you have changes the time. Do you want to continue tracking?",
                    QMessageBox.Yes | QMessageBox.No, 
                    QMessageBox.No
                )

                if reply == QMessageBox.No:

                    self.remove_point(self.points_layer)
                    self.stop_tracking()

                    return
                
                elif reply == QMessageBox.Yes:

                    self.remove_point(self.points_layer)
                    self.viewer.dims.current_step[0] = self.tracking_time+1

                    return

        # Get the added point (most recent point is the first one)
        new_point = self.points_layer.data[-1].copy()  # First point added to the layer

        if self.viewer.dims.ndisplay == 2:

            # Add tracking
            self.add_point_properties(self.points_layer)
            self.update_tracks_layer_with_new_point(new_point)
            new_point[0] += 1
            if new_point[0] < self.length:
                self.add_point(self.points_layer_aux, new_point)

            self.jump_next()

        elif self.viewer.dims.ndisplay == 3:

            # If it's the first point, store it and its direction
            if self.point1 is None:
                self.point1 = new_point
                self.direction1 = self.compute_camera_direction()  # Replace with your own logic to get direction
                if self.debugging.isChecked():
                    print(f"First point stored at: {self.point1}, direction: {self.direction1}")

                return
            
            elif self.point2 is None:

                # If it's the second point, store it and calculate the closest point
                self.point2 = new_point
                self.direction2 = self.compute_camera_direction()  # Replace with your own logic to get direction
                if self.debugging.isChecked():
                    print(f"Second point stored at: {self.point2}, direction: {self.direction2}")

                # Calculate the closest point between the two lines
                closest_point = self.calculate_closest_point(self.point1[1:], self.direction1, self.point2[1:], self.direction2)
                if self.debugging.isChecked():
                    print(f"Closest point calculated at: {closest_point}")

                # Remove the last two points (the first two added) and add the calculated closest point at the beginning
                self.update_points_layer_with_closest_point(np.append([self.point1[0]],closest_point))

                # Add tracking
                self.update_tracks_layer_with_new_point(np.append([self.point1[0]],closest_point))

                # # Update vectors layer with the vectors from points and directions
                # if self.vectorcheckbox.isChecked():
                #     self.update_vectors_layer()

                # Reset point storage for the next pair of points
                self.point1 = None
                self.point2 = None

                self.jump_next()

    def get_time(self):
        return self.viewer.dims.current_step[0]

    def remove_point(self, points_layer, pos=-1):

        self.prevent_update = True
        points_layer.data = points_layer.data[:pos]
        if "id" in points_layer.properties.keys():
            points_layer.properties["id"] = points_layer.properties["id"][:pos]
        self.prevent_update = False

        return

    def add_point(self, points_layer, point):

        self.prevent_update = True
        points_layer.data = np.vstack([points_layer.data, point])
        if "id" in points_layer.properties.keys():
            points_layer.properties["id"] = np.append(points_layer.properties["id"],[self.tracking_active_id])
        self.prevent_update = False

        return

    def add_point_properties(self, points_layer):

        if "id" in points_layer.properties.keys():
            points_layer.properties["id"][-1] = self.tracking_active_id

        return

    def jump_next(self):
        # Next step
        if self.jump_next_checkBox:
            current_time = self.get_time()
            self.viewer.dims.set_current_step(0, current_time + 1)

        return

    def update_points_layer_with_closest_point(self, closest_point):
        """
        Update the points layer: Remove the first two points and add the calculated closest point to the beginning.
        """
        # Check if there are at least two points in the layer before removing
        if len(self.points_layer.data) < 2:
            if self.debugging.isChecked():
                print("Not enough points in the layer to remove two points.")
            return

        # Remove the first two points (most recently added)
        self.remove_point(self.points_layer,pos=-2)
        # Add the calculated closest point to the beginning of the layer
        self.add_point(self.points_layer, closest_point)

        closest_point[0] += 1
        if closest_point[0] < self.length:
            self.add_point(self.points_layer_aux, closest_point)

        if self.debugging.isChecked():
            print(f"First two points removed and closest point {closest_point} appended.")

    def new_tracking(self):
        """
        Create a new tracking id and activate the tracking.
        """

        if self.tracking_active:

                msg = QMessageBox()
                msg.setWindowTitle("Stop tracking")
                msg.setText("There is an active tracking. Do you want to stop it?")
                msg.setIcon(QMessageBox.Question)

                # Add more than two buttons
                button_yes = msg.addButton("Yes", QMessageBox.ActionRole)
                button_no = msg.addButton("No", QMessageBox.ActionRole)

                msg.exec_()

                if msg.clickedButton() == button_yes:
                    self.stop_tracking()
                elif msg.clickedButton() == button_no:
                    return

        if len(self.points_layer.selected_data) == 1:

            selected_time = self.points_layer.data[self.points_layer.selected_point[0]][0]
            selected_id = self.points_layer.properties["id"][self.points_layer.selected_point[0]]

            self.viewer.dims.current_step[0] = self.selected_time

            if selected_id == np.nan:

                msg = QMessageBox()
                msg.setWindowTitle("Start from selected")
                msg.setText("There is a point selected without id. Do you want to start a tracking from this point?")
                msg.setIcon(QMessageBox.Question)

                # Add more than two buttons
                button_yes = msg.addButton("Yes", QMessageBox.ActionRole)
                button_no = msg.addButton("No", QMessageBox.ActionRole)

                msg.exec_()

                if msg.clickedButton() == button_yes:

                    self.setup_active_tracking(self, id=None, tracking_time=selected_time)

                elif msg.clickedButton() == button_no:

                    print("Option 2 selected")

            keep = self.tracking_layer.data[:,0] == selected_id
            times = np.sort(self.tracking_layer.data[keep,1])

            if np.any(times > selected_time):

                msg = QMessageBox()
                msg.setWindowTitle("Start from inner selected point")
                msg.setText(f"There is a point selected with tracking id {selected_id}. This point selected is in the middle of an existing track. What do you want to do?")
                msg.setIcon(QMessageBox.Question)

                # Add more than two buttons
                button_division = msg.addButton("Start division", QMessageBox.ActionRole)
                button2 = msg.addButton("Keep", QMessageBox.ActionRole)
                button3 = msg.addButton("Option 3", QMessageBox.ActionRole)

                msg.exec_()

                if msg.clickedButton() == button1:
                    print("Option 1 selected")
                elif msg.clickedButton() == button2:
                    print("Option 2 selected")
                elif msg.clickedButton() == button3:
                    print("Option 3 selected")

        elif self.length > self.get_time()+1:
        
            self.setup_active_tracking()

        else:
                print("We are in the final time point, we cannot start a track here.")

        return
    
    def setup_active_tracking(self, id=None, tracking_time=None):

        if id == None:
            self.tracking_max_id += 1
            self.tracking_active_id = self.tracking_max_id
        else:
            self.tracking_active_id = id

        self.tracking_active = True

        if tracking_time == None:
            self.tracking_time = self.get_time()-1
        else:
            self.tracking_time = tracking_time

        self.start_tracking_button.setStyleSheet(
                    "QPushButton {"
                        "background-color: green;"  # Green background
                    "}"
                )
        
        return

    def stop_tracking(self):
        """
        Stop tracking.
        """

        self.tracking_active = False
        self.tracking_active_id = np.nan

        self.start_tracking_button.setStyleSheet("")

        return

    def update_tracks_layer_with_new_point(self, point):
        """
        Update the tracking layer.
        """
        if self.tracking_active:
            track_point = np.append([self.tracking_active_id], point)
            self.tracking_layer.data = np.vstack([self.tracking_layer.data, track_point])

            if self.length <= self.get_time()+1:
                self.stop_tracking()

            self.tracking_time = self.get_time()

        return

    # def make_vector_layer(self):
    #     """Update the combo box with existing points layers."""
    #     if "Debug" in self.viewer.layers:
    #         if isinstance(self.viewer.layers["Debug"], napari.layers.Vectors):
    #             del self.viewer.layers["Debug"]

    #     # Add all existing Points layers to the combo box
    #     self.vectors_layer = self.viewer.add_vectors(
    #         np.zeros([0,2,3]), 
    #         name='Debug_Vectors', 
    #         length=100,
    #         edge_width=2, 
    #         edge_color='green',
    #         # scale=self.image_layer.scale[1:]
    #         )

    # def update_vectors_layer(self):
    #     """Update or create a vectors layer to visualize the directions from the points."""
    #     # Define the vector data format: [start_point, vector]
    #     scale = np.array(self.image_layer.scale[1:])
    #     vectors_data = np.array([
    #         [self.point1[1:], self.direction1],
    #         [self.point2[1:], self.direction2]
    #     ])
        
    #     self.vectors_layer.data = vectors_data
    #     print("Vectors layer updated.")

    def compute_camera_direction(self):
        """
        Compute the camera direction using the Euler angles and center of the camera.
        Napari gives the camera's Euler angles in degrees and the center of rotation.
        """

        # Calculate the view direction based on the camera's current angles
        view_direction = self.viewer.camera.calculate_nd_view_direction(3, (0,1,2))

        return view_direction

    def calculate_closest_point(self, P1, d1, P2, d2):
        """
        Finds the closest points on two skew (non-intersecting) lines in 3D.
        
        Parameters:
        P1 : np.array
            A point on line 1 (3D vector).
        d1 : np.array
            The direction vector of line 1 (3D vector).
        P2 : np.array
            A point on line 2 (3D vector).
        d2 : np.array
            The direction vector of line 2 (3D vector).
            
        Returns:
        Q1 : np.array
            Closest point on line 1 to line 2 (3D vector).
        Q2 : np.array
            Closest point on line 2 to line 1 (3D vector).
        distance : float
            The shortest distance between the two lines.
        """
        
        # Convert input points and direction vectors to numpy arrays
        scale = np.array(self.image_layer.scale[1:])
        P1 = np.array(P1)*scale
        d1 = np.array(d1)
        P2 = np.array(P2)*scale
        d2 = np.array(d2)
        
        # Vector between the two points
        P12 = P2 - P1
        
        # Cross product of the direction vectors
        n = np.cross(d1, d2)
        
        # # If the cross product is zero, the lines are parallel
        # if np.allclose(n, 0):
        #     raise ValueError("The lines are parallel and do not have a unique closest pair of points.")
        
        # Coefficients for the system of equations
        d1_dot_d1 = np.dot(d1, d1)
        d2_dot_d2 = np.dot(d2, d2)
        d1_dot_d2 = np.dot(d1, d2)
        P12_dot_d1 = np.dot(P12, d1)
        P12_dot_d2 = np.dot(P12, d2)
        
        # Solving for t1 and t2 using Cramer's rule
        denominator = d1_dot_d1 * d2_dot_d2 - d1_dot_d2**2
        t1 = (P12_dot_d1 * d2_dot_d2 - P12_dot_d2 * d1_dot_d2) / denominator
        t2 = (P12_dot_d1 * d1_dot_d2 - P12_dot_d2 * d1_dot_d1) / denominator
        
        # Find the closest points on each line
        Q1 = P1 + t1 * d1  # Closest point on line 1
        Q2 = P2 + t2 * d2  # Closest point on line 2
        
        # Compute the shortest distance between the two lines
        distance = np.linalg.norm(Q1 - Q2)
        
        return ( Q1 + Q2 ) /2 / scale

# Napari plugin function
def napari_experimental_provide_dock_widget():
    return SetUpTracking, LoadTracking, ManualTracking
