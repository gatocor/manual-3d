"""
This module contains four napari widgets declared in
different ways:

- a pure Python function flagged with `autogenerate: true`
    in the plugin manifest. Type annotations are used by
    magicgui to generate widgets for each parameter. Best
    suited for simple processing tasks - usually taking
    in and/or returning a layer.
- a `magic_factory` decorated function. The `magic_factory`
    decorator allows us to customize aspects of the resulting
    GUI, including the widgets associated with each parameter.
    Best used when you have a very simple processing task,
    but want some control over the autogenerated widgets. If you
    find yourself needing to define lots of nested functions to achieve
    your functionality, maybe look at the `Container` widget!
- a `magicgui.widgets.Container` subclass. This provides lots
    of flexibility and customization options while still supporting
    `magicgui` widgets and convenience methods for creating widgets
    from type annotations. If you want to customize your widgets and
    connect callbacks, this is the best widget option for you.
- a `QWidget` subclass. This provides maximal flexibility but requires
    full specification of widget layouts, callbacks, events, etc.

References:
- Widget specification: https://napari.org/stable/plugins/guides.html?#widgets
- magicgui docs: https://pyapp-kit.github.io/magicgui/

Replace code below according to your needs.
"""
from typing import TYPE_CHECKING

from magicgui import magic_factory
from magicgui.widgets import CheckBox, Container, create_widget
from qtpy.QtWidgets import (
    QWidget, QVBoxLayout, QLabel, QPushButton, QLineEdit, QFileDialog, QDoubleSpinBox, QSpinBox
)
from qtpy.QtCore import Qt
import os
from skimage.util import img_as_float
import numpy as np
from magicgui.widgets import FileEdit
from .utils import *
from scipy.ndimage import gaussian_filter
from skimage.feature import peak_local_max
import napari
import re
import json

if TYPE_CHECKING:
    import napari

class SetUpTracking(QWidget):
    def __init__(self, napari_viewer):
        super().__init__()

        # Add viewer
        self.viewer = napari_viewer

        # Create the layout
        self.layout = QVBoxLayout()

        # Path input
        self.path_label = QLabel("Path to Data Folder:")
        self.path_input = QLineEdit(self)
        self.browse_button = QPushButton("Browse")
        self.browse_button.clicked.connect(self.browse_folder)
        self.layout.addWidget(self.path_label)
        self.layout.addWidget(self.path_input)
        self.layout.addWidget(self.browse_button)

        # Start and end points
        self.start_label = QLabel("Start Point:")
        self.start_input = QSpinBox(self)
        self.start_input.setMinimum(0)
        self.end_label = QLabel("End Point:")
        self.end_input = QSpinBox(self)
        self.end_input.setMinimum(0)
        self.layout.addWidget(self.start_label)
        self.layout.addWidget(self.start_input)
        self.layout.addWidget(self.end_label)
        self.layout.addWidget(self.end_input)

        # Format input
        self.format_label = QLabel("Format:")
        self.format_input = QLineEdit(self)
        self.layout.addWidget(self.format_label)
        self.layout.addWidget(self.format_input)

        # Voxel sizes
        self.voxel_x_label = QLabel("Voxel X:")
        self.voxel_x_input = QDoubleSpinBox(self)
        self.voxel_x_input.setDecimals(3)  # Allow three decimal places
        self.voxel_x_input.setValue(0.347)
        self.voxel_x_input.setSingleStep(0.001)  # Step size for adjustment
        self.voxel_y_label = QLabel("Voxel Y:")
        self.voxel_y_input = QDoubleSpinBox(self)
        self.voxel_y_input.setDecimals(3)  # Allow three decimal places
        self.voxel_y_input.setValue(0.347)
        self.voxel_y_input.setSingleStep(0.001)  # Step size for adjustment
        self.voxel_z_label = QLabel("Voxel Z:")
        self.voxel_z_input = QDoubleSpinBox(self)
        self.voxel_z_input.setDecimals(3)  # Allow three decimal places
        self.voxel_z_input.setValue(2.0)
        self.voxel_z_input.setSingleStep(0.001)  # Step size for adjustment
        self.layout.addWidget(self.voxel_x_label)
        self.layout.addWidget(self.voxel_x_input)
        self.layout.addWidget(self.voxel_y_label)
        self.layout.addWidget(self.voxel_y_input)
        self.layout.addWidget(self.voxel_z_label)
        self.layout.addWidget(self.voxel_z_input)

        # Load button
        self.load_button = QPushButton("Load Movie")
        self.load_button.clicked.connect(self.load_movie)
        self.layout.addWidget(self.load_button)

        # Set the layout
        self.setLayout(self.layout)

        # Internal variable to store the number of files
        self.file_count = 0

    def browse_folder(self):
        """Open a file dialog to browse for a folder and count the number of files."""
        folder_path = QFileDialog.getExistingDirectory(self, "Select Data Folder")
        if folder_path:
            self.path_input.setText(folder_path)
            self.count_files_in_folder(folder_path)
            self.detect_file_pattern(folder_path)

    def count_files_in_folder(self, folder_path):
        """Count the number of files in the selected folder and set the start and end points."""
        try:
            file_list = os.listdir(folder_path)
            self.file_count = len(file_list)
        except Exception as e:
            print(f"Error counting files: {e}")

    def detect_file_pattern(self, folder_path):
        """Detect the file naming pattern, start and end points, and suggest it as the format."""
        try:
            file_list = os.listdir(folder_path)
            file_list = [f for f in file_list if os.path.isfile(os.path.join(folder_path, f))]
            file_list.sort()  # Ensure the files are sorted correctly

            if len(file_list) < 2:
                return  # We need at least two files to detect a pattern

            # Compare first two filenames to identify the changing numeric pattern
            file_1, file_2 = file_list[0], file_list[1]
            format_str = []
            num_pattern = re.compile(r'\d+')  # Pattern to match numbers
            numeric_values = []

            i = 0
            while i < len(file_1):
                if i < len(file_2) and file_1[i] == file_2[i]:
                    format_str.append(file_1[i])  # If characters are the same, add them to format
                elif num_pattern.match(file_1[i:]):
                    # Detect numeric sequence, determine its length
                    num_match_1 = num_pattern.match(file_1[i:])
                    num_match_2 = num_pattern.match(file_2[i:])
                    
                    if num_match_1 and num_match_2:
                        length_1 = len(num_match_1.group(0))
                        length_2 = len(num_match_2.group(0))
                        if length_1 == length_2:  # Only replace if the lengths of numbers are the same
                            format_str.append(f"{{:0{length_1}d}}")
                            # Collect the numeric values from all files to detect min/max
                            for file_name in file_list:
                                match = num_pattern.search(file_name)
                                if match:
                                    numeric_values.append(int(match.group(0)))
                            i += length_1 - 1  # Skip past the numeric part
                        else:
                            format_str.append(file_1[i])
                    else:
                        format_str.append(file_1[i])
                else:
                    format_str.append(file_1[i])
                i += 1

            # Join format string and update the format input
            detected_format = ''.join(format_str)
            self.format_input.setText(detected_format)

            # Set start and end points based on the detected numeric sequence
            if numeric_values:
                self.start_input.setValue(min(numeric_values))
                self.end_input.setValue(max(numeric_values))

        except Exception as e:
            print(f"Error detecting file pattern: {e}")

    def load_movie(self):
        """Load the movie based on the user input."""
        path_data = self.path_input.text()
        start_point = self.start_input.value()
        end_point = self.end_input.value()
        format_str = self.format_input.text()
        voxel_x = self.voxel_x_input.value()
        voxel_y = self.voxel_y_input.value()
        voxel_z = self.voxel_z_input.value()

        # Assuming read_split_times function is defined elsewhere
        image = read_split_times(
            str(path_data),
            range(start_point, end_point + 1),
            format_str
        )[0][:, :, 0, :, :]
        
        scale = [voxel_z, voxel_y, voxel_x]
        
        # Launch the Napari viewer
        self.viewer.add_image(image, scale=scale, name="Image "+self.path_input.text().split("/")[-1])

        return


# if we want even more control over our widget, we can use
# magicgui `Container`
    
from napari.utils.events import Event
from napari import Viewer
from qtpy.QtWidgets import QApplication, QWidget

# class FindPeaks(Container):
#     def __init__(self, viewer: "napari.viewer.Viewer"):
        
#         super().__init__()
#         self._viewer = viewer
#         # use create_widget to generate widgets from type annotations
#         self._image_layer = create_widget(
#             label="Image", annotation="napari.layers.Image"
#         )
#         self._points_layer = create_widget(
#             label="Points", annotation="napari.layers.Points"
#         )
#         self._gaussian_filter_slider = create_widget(
#             label="Gaussian", annotation=float, widget_type="FloatSlider"
#         )
#         self._gaussian_filter_slider.min = 0
#         self._gaussian_filter_slider.max = 100
#         # use magicgui widgets directly
#         # self._invert_checkbox = CheckBox(text="Keep pixels below threshold")

#         # connect your own callbacks
#         self._gaussian_filter_slider.changed.connect(self._threshold_im)
#         # self._invert_checkbox.changed.connect(self._threshold_im)
#         self._compute = create_widget(
#             label="Compute", annotation=float, widget_type="PushButton"
#         )

#         # append into/extend the container with your widgets
#         self.extend(
#             [
#                 self._image_layer,
#                 self._points_layer,
#                 self._gaussian_filter_slider,
#                 # self._invert_checkbox,
#                 self._compute,
#             ]
#         )

#         self._viewer.layers.events.inserting.connect(self.my_callback)

#     def my_callback(event: Event):
#         print("The number of dims shown is now:", event)        

#     def _threshold_im(self):
#         image_layer = self._image_layer_combo.value
#         if image_layer is None:
#             return

#         image = img_as_float(image_layer.data)
#         name = image_layer.name + "_thresholded"
#         threshold = self._gaussian_filter_slider.value
#         if self._invert_checkbox.value:
#             thresholded = image < threshold
#         else:
#             thresholded = image > threshold
#         if name in self._viewer.layers:
#             self._viewer.layers[name].data = thresholded
#         else:
#             self._viewer.add_labels(thresholded, name=name)


# class ExampleQWidget(QWidget):

import napari
import numpy as np
from qtpy.QtWidgets import QWidget, QVBoxLayout, QLabel, QComboBox, QCheckBox
from qtpy.QtCore import Qt

class FindPeaks(QWidget):
    def __init__(self, napari_viewer):
        super().__init__()

        self.viewer = napari_viewer
        self.points_layer = None  # This will store the linked points layer
        self.vectors_layer = None  # Vectors layer to show directions

        # To store the two points and directions
        self.point1 = None
        self.direction1 = None
        self.point2 = None
        self.direction2 = None
        self.counter = 0

        # Set up the UI
        self.setWindowTitle("FindPeaks")
        self.setGeometry(100, 100, 300, 200)

        # Layout
        layout = QVBoxLayout()

        # Label
        self.label = QLabel("Select a Points layer:")
        layout.addWidget(self.label)

        # Combo box to select existing points layer
        self.layer_selector = QComboBox()
        self.update_layer_list()  # Fill the combo box with existing layers
        layout.addWidget(self.layer_selector)
        # Connect the dropdown to automatically link when a selection is made
        self.layer_selector.currentIndexChanged.connect(self.link_to_points_layer)

        # Checkbox to enable/disable the custom callback
        self.checkbox = QCheckBox("Enable Point Added Callback")
        layout.addWidget(self.checkbox)
        # Connect the checkbox to control the point-added callback behavior
        self.checkbox.stateChanged.connect(self.toggle_point_added_callback)

        # Checkbox to enable/disable the custom callback
        self.vectorcheckbox = QCheckBox("Debug")
        layout.addWidget(self.vectorcheckbox)
        self.vectorcheckbox.stateChanged.connect(self.make_vector_layer)

        # Connect to the Napari viewer's layer insertion event
        self.viewer.layers.events.inserted.connect(self.on_layer_inserted)

        self.setLayout(layout)

    def update_layer_list(self):
        """Update the combo box with existing points layers."""
        self.layer_selector.clear()

        # Add all existing Points layers to the combo box
        for layer in self.viewer.layers:
            if isinstance(layer, napari.layers.Points):
                self.layer_selector.addItem(layer.name)

    def on_layer_inserted(self, event):
        """Triggered when a new layer is added to the viewer."""
        new_layer = event.value
        if isinstance(new_layer, napari.layers.Points):
            self.layer_selector.addItem(new_layer.name)
            print(f"New Points layer '{new_layer.name}' added to the combo box.")

    def link_to_points_layer(self):
        """Link the widget to the selected points layer."""
        selected_item = self.layer_selector.currentText()

        if selected_item:
            # Link to the selected existing points layer
            self.points_layer = self.viewer.layers[selected_item]
            print(f"Linked to existing points layer: {selected_item}")
        else:
            print("No Points layer selected.")

    def toggle_point_added_callback(self, state):
        """Enable or disable the point-added callback based on the checkbox."""
        if self.points_layer is None:
            print("No points layer selected to monitor.")
            return

        if state == Qt.Checked:
            # Connect to the points layer's event for data changes
            self.points_layer.events.data.connect(self.on_point_added)
            self.point1 = None
            self.point2 = None
            print("Point added callback enabled.")
        else:
            # Disconnect the point added event
            self.points_layer.events.data.disconnect(self.on_point_added)
            self.point1 = None
            self.point2 = None
            print("Point added callback disabled.")

    def on_point_added(self, event):
        """Callback triggered when a new point is added to the points layer."""

        if self.counter == 0:
            self.counter = 1
            return
        else:
            self.counter = 0
        
        # Check if the points layer is empty before proceeding
        if len(self.points_layer.data) == 0:
            print("Points layer is empty. No action taken.")
            return

        if self.viewer.dims.ndisplay != 3:
            print("Not in 3D mode. No action taken.")
            return

        # Get the added point (most recent point is the first one)
        new_point = self.points_layer.data[-1]  # First point added to the layer

        # If it's the first point, store it and its direction
        if self.point1 is None:
            self.point1 = new_point
            self.direction1 = self.compute_camera_direction()  # Replace with your own logic to get direction
            print(f"First point stored at: {self.point1}, direction: {self.direction1}")
        elif self.point2 is None:
            # If it's the second point, store it and calculate the closest point
            self.point2 = new_point
            self.direction2 = self.compute_camera_direction()  # Replace with your own logic to get direction
            print(f"Second point stored at: {self.point2}, direction: {self.direction2}")

            # Calculate the closest point between the two lines
            closest_point = self.calculate_closest_point(self.point1, self.direction1, self.point2, self.direction2)
            print(f"Closest point calculated at: {closest_point}")

            # Remove the last two points (the first two added) and add the calculated closest point at the beginning
            self.update_points_layer_with_closest_point(closest_point)

            # Update vectors layer with the vectors from points and directions
            if self.vectorcheckbox.isChecked():
                self.update_vectors_layer()

            # Reset point storage for the next pair of points
            self.point1 = None
            self.point2 = None

    def update_points_layer_with_closest_point(self, closest_point):
        """
        Update the points layer: Remove the first two points and add the calculated closest point to the beginning.
        """
        # Check if there are at least two points in the layer before removing
        if len(self.points_layer.data) < 2:
            print("Not enough points in the layer to remove two points.")
            return

        # Remove the first two points (most recently added)
        self.points_layer.data = self.points_layer.data[:-2]

        # Add the calculated closest point to the beginning of the layer
        self.points_layer.data = np.vstack([self.points_layer.data, closest_point])

        print(f"First two points removed and closest point {closest_point} appended.")

    def make_vector_layer(self):
        """Update the combo box with existing points layers."""
        if "Debug" in self.viewer.layers:
            if isinstance(self.viewer.layers["Debug"], napari.layers.Vectors):
                del self.viewer.layers["Debug"]

        # Add all existing Points layers to the combo box
        self.vectors_layer = self.viewer.add_vectors(
            np.zeros([0,2,3]), 
            name='Debug_Vectors', 
            length=100,
            edge_width=2, 
            edge_color='green')

    def update_vectors_layer(self):
        """Update or create a vectors layer to visualize the directions from the points."""
        # Define the vector data format: [start_point, vector]
        vectors_data = np.array([
            [self.point1, self.direction1],
            [self.point2, self.direction2]
        ])
        
        self.vectors_layer.data = vectors_data
        print("Vectors layer updated.")

    def compute_camera_direction(self):
        """
        Compute the camera direction using the Euler angles and center of the camera.
        Napari gives the camera's Euler angles in degrees and the center of rotation.
        """

        return self.viewer.camera.calculate_nd_view_direction(3,self.viewer.dims.order)

    def calculate_closest_point(self, P1, d1, P2, d2):
        """
        Finds the closest points on two skew (non-intersecting) lines in 3D.
        
        Parameters:
        P1 : np.array
            A point on line 1 (3D vector).
        d1 : np.array
            The direction vector of line 1 (3D vector).
        P2 : np.array
            A point on line 2 (3D vector).
        d2 : np.array
            The direction vector of line 2 (3D vector).
            
        Returns:
        Q1 : np.array
            Closest point on line 1 to line 2 (3D vector).
        Q2 : np.array
            Closest point on line 2 to line 1 (3D vector).
        distance : float
            The shortest distance between the two lines.
        """
        
        # Convert input points and direction vectors to numpy arrays
        P1 = np.array(P1)
        d1 = np.array(d1)
        P2 = np.array(P2)
        d2 = np.array(d2)
        
        # Vector between the two points
        P12 = P2 - P1
        
        # Cross product of the direction vectors
        n = np.cross(d1, d2)
        
        # # If the cross product is zero, the lines are parallel
        # if np.allclose(n, 0):
        #     raise ValueError("The lines are parallel and do not have a unique closest pair of points.")
        
        # Coefficients for the system of equations
        d1_dot_d1 = np.dot(d1, d1)
        d2_dot_d2 = np.dot(d2, d2)
        d1_dot_d2 = np.dot(d1, d2)
        P12_dot_d1 = np.dot(P12, d1)
        P12_dot_d2 = np.dot(P12, d2)
        
        # Solving for t1 and t2 using Cramer's rule
        denominator = d1_dot_d1 * d2_dot_d2 - d1_dot_d2**2
        t1 = (P12_dot_d1 * d2_dot_d2 - P12_dot_d2 * d1_dot_d2) / denominator
        t2 = (P12_dot_d1 * d1_dot_d2 - P12_dot_d2 * d1_dot_d1) / denominator
        
        # Find the closest points on each line
        Q1 = P1 + t1 * d1  # Closest point on line 1
        Q2 = P2 + t2 * d2  # Closest point on line 2
        
        # Compute the shortest distance between the two lines
        distance = np.linalg.norm(Q1 - Q2)
        
        return ( Q1 + Q2 ) /2

    def showEvent(self, event):
        """Triggered when the widget is shown, updates the layer list."""
        self.update_layer_list()  # Update the list of layers whenever the widget is shown
        print("Widget shown and layer list updated.")
        super().showEvent(event)

    def hideEvent(self, event):
        """Triggered when the widget is hidden, disconnect the point added callback if active."""
        if self.points_layer is not None and self.checkbox.isChecked():
            self.points_layer.events.data.disconnect(self.on_point_added)
        print("Point added callback unlinked upon hiding.")
        super().hideEvent(event)


# Napari plugin function
def napari_experimental_provide_dock_widget():
    return SetUpTracking
